schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "BondingCurve"
"""
type BondingCurve {
  address: String!
  bcType: String
  buyFee: numeric!
  buyReserveRatio: numeric!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!

  """An array relationship"""
  curveDayData(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """An array relationship"""
  curveHourData(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!
  db_write_timestamp: timestamp
  id: String!

  """An object relationship"""
  issuanceToken: Token

  """An array relationship"""
  issuanceTokenDayData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """An array relationship"""
  issuanceTokenHourData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!
  issuanceToken_id: String!

  """An array relationship"""
  projectFees(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """An array relationship"""
  protocolFees(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!
  reserveCOL: numeric!
  reserveUSD: numeric!
  sellFee: numeric!
  sellReserveRatio: numeric!

  """An array relationship"""
  swaps(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!
  virtualCOL: numeric!
  virtualISS: numeric!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "BondingCurve". All fields are combined with a logical 'AND'.
"""
input BondingCurve_bool_exp {
  _and: [BondingCurve_bool_exp!]
  _not: BondingCurve_bool_exp
  _or: [BondingCurve_bool_exp!]
  address: String_comparison_exp
  bcType: String_comparison_exp
  buyFee: numeric_comparison_exp
  buyReserveRatio: numeric_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  curveDayData: CurveDayData_bool_exp
  curveHourData: CurveHourData_bool_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceTokenDayData: IssuanceTokenDayData_bool_exp
  issuanceTokenHourData: IssuanceTokenHourData_bool_exp
  issuanceToken_id: String_comparison_exp
  projectFees: ProjectFee_bool_exp
  protocolFees: ProtocolFee_bool_exp
  reserveCOL: numeric_comparison_exp
  reserveUSD: numeric_comparison_exp
  sellFee: numeric_comparison_exp
  sellReserveRatio: numeric_comparison_exp
  swaps: Swap_bool_exp
  virtualCOL: numeric_comparison_exp
  virtualISS: numeric_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "BondingCurve"."""
input BondingCurve_order_by {
  address: order_by
  bcType: order_by
  buyFee: order_by
  buyReserveRatio: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  curveDayData_aggregate: CurveDayData_aggregate_order_by
  curveHourData_aggregate: CurveHourData_aggregate_order_by
  db_write_timestamp: order_by
  id: order_by
  issuanceToken: Token_order_by
  issuanceTokenDayData_aggregate: IssuanceTokenDayData_aggregate_order_by
  issuanceTokenHourData_aggregate: IssuanceTokenHourData_aggregate_order_by
  issuanceToken_id: order_by
  projectFees_aggregate: ProjectFee_aggregate_order_by
  protocolFees_aggregate: ProtocolFee_aggregate_order_by
  reserveCOL: order_by
  reserveUSD: order_by
  sellFee: order_by
  sellReserveRatio: order_by
  swaps_aggregate: Swap_aggregate_order_by
  virtualCOL: order_by
  virtualISS: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "BondingCurve"
"""
enum BondingCurve_select_column {
  """column name"""
  address

  """column name"""
  bcType

  """column name"""
  buyFee

  """column name"""
  buyReserveRatio

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  issuanceToken_id

  """column name"""
  reserveCOL

  """column name"""
  reserveUSD

  """column name"""
  sellFee

  """column name"""
  sellReserveRatio

  """column name"""
  virtualCOL

  """column name"""
  virtualISS

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "BondingCurve"
"""
input BondingCurve_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BondingCurve_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BondingCurve_stream_cursor_value_input {
  address: String
  bcType: String
  buyFee: numeric
  buyReserveRatio: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  id: String
  issuanceToken_id: String
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  sellReserveRatio: numeric
  virtualCOL: numeric
  virtualISS: numeric
  workflow_id: String
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "Bounty"
"""
type Bounty {
  """An object relationship"""
  bountyModule: BountyModule
  bountyModule_id: String!

  """An array relationship"""
  claims(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!
  db_write_timestamp: timestamp
  details: String!
  id: String!
  locked: Boolean
  maximumPayoutAmount: numeric!
  minimumPayoutAmount: numeric!
}

"""
columns and relationships of "BountyClaim"
"""
type BountyClaim {
  """An object relationship"""
  bounty: Bounty
  bounty_id: String!
  claimed: Boolean

  """An array relationship"""
  contributors(
    """distinct select on columns"""
    distinct_on: [BountyContributor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyContributor_order_by!]

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!
  db_write_timestamp: timestamp
  details: String!
  id: String!
}

"""
order by aggregate values of table "BountyClaim"
"""
input BountyClaim_aggregate_order_by {
  count: order_by
  max: BountyClaim_max_order_by
  min: BountyClaim_min_order_by
}

"""
Boolean expression to filter rows from the table "BountyClaim". All fields are combined with a logical 'AND'.
"""
input BountyClaim_bool_exp {
  _and: [BountyClaim_bool_exp!]
  _not: BountyClaim_bool_exp
  _or: [BountyClaim_bool_exp!]
  bounty: Bounty_bool_exp
  bounty_id: String_comparison_exp
  claimed: Boolean_comparison_exp
  contributors: BountyContributor_bool_exp
  db_write_timestamp: timestamp_comparison_exp
  details: String_comparison_exp
  id: String_comparison_exp
}

"""
order by max() on columns of table "BountyClaim"
"""
input BountyClaim_max_order_by {
  bounty_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
}

"""
order by min() on columns of table "BountyClaim"
"""
input BountyClaim_min_order_by {
  bounty_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
}

"""Ordering options when selecting data from "BountyClaim"."""
input BountyClaim_order_by {
  bounty: Bounty_order_by
  bounty_id: order_by
  claimed: order_by
  contributors_aggregate: BountyContributor_aggregate_order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
}

"""
select columns of table "BountyClaim"
"""
enum BountyClaim_select_column {
  """column name"""
  bounty_id

  """column name"""
  claimed

  """column name"""
  db_write_timestamp

  """column name"""
  details

  """column name"""
  id
}

"""
Streaming cursor of the table "BountyClaim"
"""
input BountyClaim_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BountyClaim_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BountyClaim_stream_cursor_value_input {
  bounty_id: String
  claimed: Boolean
  db_write_timestamp: timestamp
  details: String
  id: String
}

"""
columns and relationships of "BountyContributor"
"""
type BountyContributor {
  address: String!

  """An object relationship"""
  bountyClaim: BountyClaim
  bountyClaim_id: String!
  claimAmount: numeric!
  db_write_timestamp: timestamp
  id: String!
}

"""
order by aggregate values of table "BountyContributor"
"""
input BountyContributor_aggregate_order_by {
  avg: BountyContributor_avg_order_by
  count: order_by
  max: BountyContributor_max_order_by
  min: BountyContributor_min_order_by
  stddev: BountyContributor_stddev_order_by
  stddev_pop: BountyContributor_stddev_pop_order_by
  stddev_samp: BountyContributor_stddev_samp_order_by
  sum: BountyContributor_sum_order_by
  var_pop: BountyContributor_var_pop_order_by
  var_samp: BountyContributor_var_samp_order_by
  variance: BountyContributor_variance_order_by
}

"""
order by avg() on columns of table "BountyContributor"
"""
input BountyContributor_avg_order_by {
  claimAmount: order_by
}

"""
Boolean expression to filter rows from the table "BountyContributor". All fields are combined with a logical 'AND'.
"""
input BountyContributor_bool_exp {
  _and: [BountyContributor_bool_exp!]
  _not: BountyContributor_bool_exp
  _or: [BountyContributor_bool_exp!]
  address: String_comparison_exp
  bountyClaim: BountyClaim_bool_exp
  bountyClaim_id: String_comparison_exp
  claimAmount: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
}

"""
order by max() on columns of table "BountyContributor"
"""
input BountyContributor_max_order_by {
  address: order_by
  bountyClaim_id: order_by
  claimAmount: order_by
  db_write_timestamp: order_by
  id: order_by
}

"""
order by min() on columns of table "BountyContributor"
"""
input BountyContributor_min_order_by {
  address: order_by
  bountyClaim_id: order_by
  claimAmount: order_by
  db_write_timestamp: order_by
  id: order_by
}

"""Ordering options when selecting data from "BountyContributor"."""
input BountyContributor_order_by {
  address: order_by
  bountyClaim: BountyClaim_order_by
  bountyClaim_id: order_by
  claimAmount: order_by
  db_write_timestamp: order_by
  id: order_by
}

"""
select columns of table "BountyContributor"
"""
enum BountyContributor_select_column {
  """column name"""
  address

  """column name"""
  bountyClaim_id

  """column name"""
  claimAmount

  """column name"""
  db_write_timestamp

  """column name"""
  id
}

"""
order by stddev() on columns of table "BountyContributor"
"""
input BountyContributor_stddev_order_by {
  claimAmount: order_by
}

"""
order by stddev_pop() on columns of table "BountyContributor"
"""
input BountyContributor_stddev_pop_order_by {
  claimAmount: order_by
}

"""
order by stddev_samp() on columns of table "BountyContributor"
"""
input BountyContributor_stddev_samp_order_by {
  claimAmount: order_by
}

"""
Streaming cursor of the table "BountyContributor"
"""
input BountyContributor_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BountyContributor_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BountyContributor_stream_cursor_value_input {
  address: String
  bountyClaim_id: String
  claimAmount: numeric
  db_write_timestamp: timestamp
  id: String
}

"""
order by sum() on columns of table "BountyContributor"
"""
input BountyContributor_sum_order_by {
  claimAmount: order_by
}

"""
order by var_pop() on columns of table "BountyContributor"
"""
input BountyContributor_var_pop_order_by {
  claimAmount: order_by
}

"""
order by var_samp() on columns of table "BountyContributor"
"""
input BountyContributor_var_samp_order_by {
  claimAmount: order_by
}

"""
order by variance() on columns of table "BountyContributor"
"""
input BountyContributor_variance_order_by {
  claimAmount: order_by
}

"""
columns and relationships of "BountyModule"
"""
type BountyModule {
  """An array relationship"""
  bounties(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "BountyModule". All fields are combined with a logical 'AND'.
"""
input BountyModule_bool_exp {
  _and: [BountyModule_bool_exp!]
  _not: BountyModule_bool_exp
  _or: [BountyModule_bool_exp!]
  bounties: Bounty_bool_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "BountyModule"."""
input BountyModule_order_by {
  bounties_aggregate: Bounty_aggregate_order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "BountyModule"
"""
enum BountyModule_select_column {
  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "BountyModule"
"""
input BountyModule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BountyModule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BountyModule_stream_cursor_value_input {
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  workflow_id: String
}

"""
order by aggregate values of table "Bounty"
"""
input Bounty_aggregate_order_by {
  avg: Bounty_avg_order_by
  count: order_by
  max: Bounty_max_order_by
  min: Bounty_min_order_by
  stddev: Bounty_stddev_order_by
  stddev_pop: Bounty_stddev_pop_order_by
  stddev_samp: Bounty_stddev_samp_order_by
  sum: Bounty_sum_order_by
  var_pop: Bounty_var_pop_order_by
  var_samp: Bounty_var_samp_order_by
  variance: Bounty_variance_order_by
}

"""
order by avg() on columns of table "Bounty"
"""
input Bounty_avg_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
Boolean expression to filter rows from the table "Bounty". All fields are combined with a logical 'AND'.
"""
input Bounty_bool_exp {
  _and: [Bounty_bool_exp!]
  _not: Bounty_bool_exp
  _or: [Bounty_bool_exp!]
  bountyModule: BountyModule_bool_exp
  bountyModule_id: String_comparison_exp
  claims: BountyClaim_bool_exp
  db_write_timestamp: timestamp_comparison_exp
  details: String_comparison_exp
  id: String_comparison_exp
  locked: Boolean_comparison_exp
  maximumPayoutAmount: numeric_comparison_exp
  minimumPayoutAmount: numeric_comparison_exp
}

"""
order by max() on columns of table "Bounty"
"""
input Bounty_max_order_by {
  bountyModule_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
order by min() on columns of table "Bounty"
"""
input Bounty_min_order_by {
  bountyModule_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""Ordering options when selecting data from "Bounty"."""
input Bounty_order_by {
  bountyModule: BountyModule_order_by
  bountyModule_id: order_by
  claims_aggregate: BountyClaim_aggregate_order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
  locked: order_by
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
select columns of table "Bounty"
"""
enum Bounty_select_column {
  """column name"""
  bountyModule_id

  """column name"""
  db_write_timestamp

  """column name"""
  details

  """column name"""
  id

  """column name"""
  locked

  """column name"""
  maximumPayoutAmount

  """column name"""
  minimumPayoutAmount
}

"""
order by stddev() on columns of table "Bounty"
"""
input Bounty_stddev_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
order by stddev_pop() on columns of table "Bounty"
"""
input Bounty_stddev_pop_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
order by stddev_samp() on columns of table "Bounty"
"""
input Bounty_stddev_samp_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
Streaming cursor of the table "Bounty"
"""
input Bounty_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Bounty_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Bounty_stream_cursor_value_input {
  bountyModule_id: String
  db_write_timestamp: timestamp
  details: String
  id: String
  locked: Boolean
  maximumPayoutAmount: numeric
  minimumPayoutAmount: numeric
}

"""
order by sum() on columns of table "Bounty"
"""
input Bounty_sum_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
order by var_pop() on columns of table "Bounty"
"""
input Bounty_var_pop_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
order by var_samp() on columns of table "Bounty"
"""
input Bounty_var_samp_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
order by variance() on columns of table "Bounty"
"""
input Bounty_variance_order_by {
  maximumPayoutAmount: order_by
  minimumPayoutAmount: order_by
}

"""
columns and relationships of "CurveDayData"
"""
type CurveDayData {
  chainId: Int!
  closeCOL: numeric!
  closeUSD: numeric!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  date: Int!
  db_write_timestamp: timestamp
  highCOL: numeric!
  highUSD: numeric!
  id: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!
  lowCOL: numeric!
  lowUSD: numeric!
  module_id: String!
  openCOL: numeric!
  openUSD: numeric!
  priceCOL: numeric!
  priceUSD: numeric!
  projectFeeCOL: numeric!
  projectFeeUSD: numeric!
  protocolFeeCOL: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!
  volumeCOL: numeric!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
order by aggregate values of table "CurveDayData"
"""
input CurveDayData_aggregate_order_by {
  avg: CurveDayData_avg_order_by
  count: order_by
  max: CurveDayData_max_order_by
  min: CurveDayData_min_order_by
  stddev: CurveDayData_stddev_order_by
  stddev_pop: CurveDayData_stddev_pop_order_by
  stddev_samp: CurveDayData_stddev_samp_order_by
  sum: CurveDayData_sum_order_by
  var_pop: CurveDayData_var_pop_order_by
  var_samp: CurveDayData_var_samp_order_by
  variance: CurveDayData_variance_order_by
}

"""
order by avg() on columns of table "CurveDayData"
"""
input CurveDayData_avg_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "CurveDayData". All fields are combined with a logical 'AND'.
"""
input CurveDayData_bool_exp {
  _and: [CurveDayData_bool_exp!]
  _not: CurveDayData_bool_exp
  _or: [CurveDayData_bool_exp!]
  chainId: Int_comparison_exp
  closeCOL: numeric_comparison_exp
  closeUSD: numeric_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  date: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  highCOL: numeric_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  lowCOL: numeric_comparison_exp
  lowUSD: numeric_comparison_exp
  module_id: String_comparison_exp
  openCOL: numeric_comparison_exp
  openUSD: numeric_comparison_exp
  priceCOL: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeCOL: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeCOL: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  volumeCOL: numeric_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""
order by max() on columns of table "CurveDayData"
"""
input CurveDayData_max_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  date: order_by
  db_write_timestamp: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  module_id: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by min() on columns of table "CurveDayData"
"""
input CurveDayData_min_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  date: order_by
  db_write_timestamp: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  module_id: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "CurveDayData"."""
input CurveDayData_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  date: order_by
  db_write_timestamp: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  module_id: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "CurveDayData"
"""
enum CurveDayData_select_column {
  """column name"""
  chainId

  """column name"""
  closeCOL

  """column name"""
  closeUSD

  """column name"""
  collateralToken_id

  """column name"""
  date

  """column name"""
  db_write_timestamp

  """column name"""
  highCOL

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  issuanceToken_id

  """column name"""
  lowCOL

  """column name"""
  lowUSD

  """column name"""
  module_id

  """column name"""
  openCOL

  """column name"""
  openUSD

  """column name"""
  priceCOL

  """column name"""
  priceUSD

  """column name"""
  projectFeeCOL

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeCOL

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  volumeCOL

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""
order by stddev() on columns of table "CurveDayData"
"""
input CurveDayData_stddev_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_pop() on columns of table "CurveDayData"
"""
input CurveDayData_stddev_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_samp() on columns of table "CurveDayData"
"""
input CurveDayData_stddev_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "CurveDayData"
"""
input CurveDayData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: CurveDayData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input CurveDayData_stream_cursor_value_input {
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  date: Int
  db_write_timestamp: timestamp
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  module_id: String
  openCOL: numeric
  openUSD: numeric
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "CurveDayData"
"""
input CurveDayData_sum_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_pop() on columns of table "CurveDayData"
"""
input CurveDayData_var_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_samp() on columns of table "CurveDayData"
"""
input CurveDayData_var_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by variance() on columns of table "CurveDayData"
"""
input CurveDayData_variance_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "CurveHourData"
"""
type CurveHourData {
  chainId: Int!
  closeCOL: numeric!
  closeUSD: numeric!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  db_write_timestamp: timestamp
  highCOL: numeric!
  highUSD: numeric!
  id: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!
  lowCOL: numeric!
  lowUSD: numeric!
  module_id: String!
  openCOL: numeric!
  openUSD: numeric!
  periodStartUnix: Int!
  priceCOL: numeric!
  priceUSD: numeric!
  projectFeeCOL: numeric!
  projectFeeUSD: numeric!
  protocolFeeCOL: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!
  volumeCOL: numeric!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
order by aggregate values of table "CurveHourData"
"""
input CurveHourData_aggregate_order_by {
  avg: CurveHourData_avg_order_by
  count: order_by
  max: CurveHourData_max_order_by
  min: CurveHourData_min_order_by
  stddev: CurveHourData_stddev_order_by
  stddev_pop: CurveHourData_stddev_pop_order_by
  stddev_samp: CurveHourData_stddev_samp_order_by
  sum: CurveHourData_sum_order_by
  var_pop: CurveHourData_var_pop_order_by
  var_samp: CurveHourData_var_samp_order_by
  variance: CurveHourData_variance_order_by
}

"""
order by avg() on columns of table "CurveHourData"
"""
input CurveHourData_avg_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "CurveHourData". All fields are combined with a logical 'AND'.
"""
input CurveHourData_bool_exp {
  _and: [CurveHourData_bool_exp!]
  _not: CurveHourData_bool_exp
  _or: [CurveHourData_bool_exp!]
  chainId: Int_comparison_exp
  closeCOL: numeric_comparison_exp
  closeUSD: numeric_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  highCOL: numeric_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  lowCOL: numeric_comparison_exp
  lowUSD: numeric_comparison_exp
  module_id: String_comparison_exp
  openCOL: numeric_comparison_exp
  openUSD: numeric_comparison_exp
  periodStartUnix: Int_comparison_exp
  priceCOL: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeCOL: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeCOL: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  volumeCOL: numeric_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""
order by max() on columns of table "CurveHourData"
"""
input CurveHourData_max_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  module_id: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by min() on columns of table "CurveHourData"
"""
input CurveHourData_min_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  module_id: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "CurveHourData"."""
input CurveHourData_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  module_id: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "CurveHourData"
"""
enum CurveHourData_select_column {
  """column name"""
  chainId

  """column name"""
  closeCOL

  """column name"""
  closeUSD

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  highCOL

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  issuanceToken_id

  """column name"""
  lowCOL

  """column name"""
  lowUSD

  """column name"""
  module_id

  """column name"""
  openCOL

  """column name"""
  openUSD

  """column name"""
  periodStartUnix

  """column name"""
  priceCOL

  """column name"""
  priceUSD

  """column name"""
  projectFeeCOL

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeCOL

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  volumeCOL

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""
order by stddev() on columns of table "CurveHourData"
"""
input CurveHourData_stddev_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_pop() on columns of table "CurveHourData"
"""
input CurveHourData_stddev_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_samp() on columns of table "CurveHourData"
"""
input CurveHourData_stddev_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "CurveHourData"
"""
input CurveHourData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: CurveHourData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input CurveHourData_stream_cursor_value_input {
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  db_write_timestamp: timestamp
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  module_id: String
  openCOL: numeric
  openUSD: numeric
  periodStartUnix: Int
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "CurveHourData"
"""
input CurveHourData_sum_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_pop() on columns of table "CurveHourData"
"""
input CurveHourData_var_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_samp() on columns of table "CurveHourData"
"""
input CurveHourData_var_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by variance() on columns of table "CurveHourData"
"""
input CurveHourData_variance_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "Deposit"
"""
type Deposit {
  amount: numeric!
  amountUSD: numeric!
  blockTimestamp: Int!
  db_write_timestamp: timestamp

  """An object relationship"""
  depositVault: DepositVault
  depositVault_id: String!
  depositor: String!
  id: String!
}

"""
columns and relationships of "DepositVault"
"""
type DepositVault {
  address: String!
  balance: numeric!
  balanceUSD: numeric!
  chainId: Int!
  db_write_timestamp: timestamp

  """An array relationship"""
  deposits(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!
  id: String!

  """An object relationship"""
  token: Token
  token_id: String!

  """An array relationship"""
  transfers(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "DepositVault". All fields are combined with a logical 'AND'.
"""
input DepositVault_bool_exp {
  _and: [DepositVault_bool_exp!]
  _not: DepositVault_bool_exp
  _or: [DepositVault_bool_exp!]
  address: String_comparison_exp
  balance: numeric_comparison_exp
  balanceUSD: numeric_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  deposits: Deposit_bool_exp
  id: String_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  transfers: Transfer_bool_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "DepositVault"."""
input DepositVault_order_by {
  address: order_by
  balance: order_by
  balanceUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  deposits_aggregate: Deposit_aggregate_order_by
  id: order_by
  token: Token_order_by
  token_id: order_by
  transfers_aggregate: Transfer_aggregate_order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "DepositVault"
"""
enum DepositVault_select_column {
  """column name"""
  address

  """column name"""
  balance

  """column name"""
  balanceUSD

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  token_id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "DepositVault"
"""
input DepositVault_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: DepositVault_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input DepositVault_stream_cursor_value_input {
  address: String
  balance: numeric
  balanceUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  token_id: String
  workflow_id: String
}

"""
order by aggregate values of table "Deposit"
"""
input Deposit_aggregate_order_by {
  avg: Deposit_avg_order_by
  count: order_by
  max: Deposit_max_order_by
  min: Deposit_min_order_by
  stddev: Deposit_stddev_order_by
  stddev_pop: Deposit_stddev_pop_order_by
  stddev_samp: Deposit_stddev_samp_order_by
  sum: Deposit_sum_order_by
  var_pop: Deposit_var_pop_order_by
  var_samp: Deposit_var_samp_order_by
  variance: Deposit_variance_order_by
}

"""
order by avg() on columns of table "Deposit"
"""
input Deposit_avg_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
Boolean expression to filter rows from the table "Deposit". All fields are combined with a logical 'AND'.
"""
input Deposit_bool_exp {
  _and: [Deposit_bool_exp!]
  _not: Deposit_bool_exp
  _or: [Deposit_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  depositVault: DepositVault_bool_exp
  depositVault_id: String_comparison_exp
  depositor: String_comparison_exp
  id: String_comparison_exp
}

"""
order by max() on columns of table "Deposit"
"""
input Deposit_max_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  depositor: order_by
  id: order_by
}

"""
order by min() on columns of table "Deposit"
"""
input Deposit_min_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  depositor: order_by
  id: order_by
}

"""Ordering options when selecting data from "Deposit"."""
input Deposit_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  db_write_timestamp: order_by
  depositVault: DepositVault_order_by
  depositVault_id: order_by
  depositor: order_by
  id: order_by
}

"""
select columns of table "Deposit"
"""
enum Deposit_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  blockTimestamp

  """column name"""
  db_write_timestamp

  """column name"""
  depositVault_id

  """column name"""
  depositor

  """column name"""
  id
}

"""
order by stddev() on columns of table "Deposit"
"""
input Deposit_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by stddev_pop() on columns of table "Deposit"
"""
input Deposit_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by stddev_samp() on columns of table "Deposit"
"""
input Deposit_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
Streaming cursor of the table "Deposit"
"""
input Deposit_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Deposit_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Deposit_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  blockTimestamp: Int
  db_write_timestamp: timestamp
  depositVault_id: String
  depositor: String
  id: String
}

"""
order by sum() on columns of table "Deposit"
"""
input Deposit_sum_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by var_pop() on columns of table "Deposit"
"""
input Deposit_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by var_samp() on columns of table "Deposit"
"""
input Deposit_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by variance() on columns of table "Deposit"
"""
input Deposit_variance_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "IssuanceTokenDayData"
"""
type IssuanceTokenDayData {
  chainId: Int!
  closeUSD: numeric!
  date: Int!
  db_write_timestamp: timestamp
  highUSD: numeric!
  id: String!
  lowUSD: numeric!
  openUSD: numeric!
  priceUSD: numeric!
  projectFeeUSD: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!
  token_id: String!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
order by aggregate values of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_aggregate_order_by {
  avg: IssuanceTokenDayData_avg_order_by
  count: order_by
  max: IssuanceTokenDayData_max_order_by
  min: IssuanceTokenDayData_min_order_by
  stddev: IssuanceTokenDayData_stddev_order_by
  stddev_pop: IssuanceTokenDayData_stddev_pop_order_by
  stddev_samp: IssuanceTokenDayData_stddev_samp_order_by
  sum: IssuanceTokenDayData_sum_order_by
  var_pop: IssuanceTokenDayData_var_pop_order_by
  var_samp: IssuanceTokenDayData_var_samp_order_by
  variance: IssuanceTokenDayData_variance_order_by
}

"""
order by avg() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_avg_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "IssuanceTokenDayData". All fields are combined with a logical 'AND'.
"""
input IssuanceTokenDayData_bool_exp {
  _and: [IssuanceTokenDayData_bool_exp!]
  _not: IssuanceTokenDayData_bool_exp
  _or: [IssuanceTokenDayData_bool_exp!]
  chainId: Int_comparison_exp
  closeUSD: numeric_comparison_exp
  date: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  lowUSD: numeric_comparison_exp
  openUSD: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  token_id: String_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""
order by max() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_max_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by min() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_min_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "IssuanceTokenDayData"."""
input IssuanceTokenDayData_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "IssuanceTokenDayData"
"""
enum IssuanceTokenDayData_select_column {
  """column name"""
  chainId

  """column name"""
  closeUSD

  """column name"""
  date

  """column name"""
  db_write_timestamp

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  lowUSD

  """column name"""
  openUSD

  """column name"""
  priceUSD

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  token_id

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""
order by stddev() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stddev_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_pop() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stddev_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_samp() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stddev_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: IssuanceTokenDayData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input IssuanceTokenDayData_stream_cursor_value_input {
  chainId: Int
  closeUSD: numeric
  date: Int
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  openUSD: numeric
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_sum_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_pop() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_var_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_samp() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_var_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by variance() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_variance_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "IssuanceTokenHourData"
"""
type IssuanceTokenHourData {
  chainId: Int!
  closeUSD: numeric!
  db_write_timestamp: timestamp
  highUSD: numeric!
  id: String!
  lowUSD: numeric!
  openUSD: numeric!
  periodStartUnix: Int!
  priceUSD: numeric!
  projectFeeUSD: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!
  token_id: String!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
order by aggregate values of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_aggregate_order_by {
  avg: IssuanceTokenHourData_avg_order_by
  count: order_by
  max: IssuanceTokenHourData_max_order_by
  min: IssuanceTokenHourData_min_order_by
  stddev: IssuanceTokenHourData_stddev_order_by
  stddev_pop: IssuanceTokenHourData_stddev_pop_order_by
  stddev_samp: IssuanceTokenHourData_stddev_samp_order_by
  sum: IssuanceTokenHourData_sum_order_by
  var_pop: IssuanceTokenHourData_var_pop_order_by
  var_samp: IssuanceTokenHourData_var_samp_order_by
  variance: IssuanceTokenHourData_variance_order_by
}

"""
order by avg() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_avg_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "IssuanceTokenHourData". All fields are combined with a logical 'AND'.
"""
input IssuanceTokenHourData_bool_exp {
  _and: [IssuanceTokenHourData_bool_exp!]
  _not: IssuanceTokenHourData_bool_exp
  _or: [IssuanceTokenHourData_bool_exp!]
  chainId: Int_comparison_exp
  closeUSD: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  lowUSD: numeric_comparison_exp
  openUSD: numeric_comparison_exp
  periodStartUnix: Int_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  token_id: String_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""
order by max() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_max_order_by {
  chainId: order_by
  closeUSD: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by min() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_min_order_by {
  chainId: order_by
  closeUSD: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "IssuanceTokenHourData"."""
input IssuanceTokenHourData_order_by {
  chainId: order_by
  closeUSD: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "IssuanceTokenHourData"
"""
enum IssuanceTokenHourData_select_column {
  """column name"""
  chainId

  """column name"""
  closeUSD

  """column name"""
  db_write_timestamp

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  lowUSD

  """column name"""
  openUSD

  """column name"""
  periodStartUnix

  """column name"""
  priceUSD

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  token_id

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""
order by stddev() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stddev_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_pop() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stddev_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by stddev_samp() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stddev_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: IssuanceTokenHourData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input IssuanceTokenHourData_stream_cursor_value_input {
  chainId: Int
  closeUSD: numeric
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  openUSD: numeric
  periodStartUnix: Int
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_sum_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_pop() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_var_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by var_samp() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_var_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
order by variance() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_variance_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "LinearVesting"
"""
type LinearVesting {
  amount: numeric!
  blockTimestamp: Int!
  chainId: Int!
  cliff: numeric!
  db_write_timestamp: timestamp
  end: numeric!
  id: String!
  recipient: String!
  start: numeric!
  status: vestingstatus!

  """An object relationship"""
  streamingPaymentProcessor: StreamingPaymentProcessor
  streamingPaymentProcessor_id: String!

  """An object relationship"""
  token: Token
  token_id: String!
}

"""
order by aggregate values of table "LinearVesting"
"""
input LinearVesting_aggregate_order_by {
  avg: LinearVesting_avg_order_by
  count: order_by
  max: LinearVesting_max_order_by
  min: LinearVesting_min_order_by
  stddev: LinearVesting_stddev_order_by
  stddev_pop: LinearVesting_stddev_pop_order_by
  stddev_samp: LinearVesting_stddev_samp_order_by
  sum: LinearVesting_sum_order_by
  var_pop: LinearVesting_var_pop_order_by
  var_samp: LinearVesting_var_samp_order_by
  variance: LinearVesting_variance_order_by
}

"""
order by avg() on columns of table "LinearVesting"
"""
input LinearVesting_avg_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
Boolean expression to filter rows from the table "LinearVesting". All fields are combined with a logical 'AND'.
"""
input LinearVesting_bool_exp {
  _and: [LinearVesting_bool_exp!]
  _not: LinearVesting_bool_exp
  _or: [LinearVesting_bool_exp!]
  amount: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  chainId: Int_comparison_exp
  cliff: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  end: numeric_comparison_exp
  id: String_comparison_exp
  recipient: String_comparison_exp
  start: numeric_comparison_exp
  status: vestingstatus_comparison_exp
  streamingPaymentProcessor: StreamingPaymentProcessor_bool_exp
  streamingPaymentProcessor_id: String_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
}

"""
order by max() on columns of table "LinearVesting"
"""
input LinearVesting_max_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor_id: order_by
  token_id: order_by
}

"""
order by min() on columns of table "LinearVesting"
"""
input LinearVesting_min_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor_id: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "LinearVesting"."""
input LinearVesting_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor: StreamingPaymentProcessor_order_by
  streamingPaymentProcessor_id: order_by
  token: Token_order_by
  token_id: order_by
}

"""
select columns of table "LinearVesting"
"""
enum LinearVesting_select_column {
  """column name"""
  amount

  """column name"""
  blockTimestamp

  """column name"""
  chainId

  """column name"""
  cliff

  """column name"""
  db_write_timestamp

  """column name"""
  end

  """column name"""
  id

  """column name"""
  recipient

  """column name"""
  start

  """column name"""
  status

  """column name"""
  streamingPaymentProcessor_id

  """column name"""
  token_id
}

"""
order by stddev() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by stddev_pop() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_pop_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by stddev_samp() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_samp_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
Streaming cursor of the table "LinearVesting"
"""
input LinearVesting_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: LinearVesting_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input LinearVesting_stream_cursor_value_input {
  amount: numeric
  blockTimestamp: Int
  chainId: Int
  cliff: numeric
  db_write_timestamp: timestamp
  end: numeric
  id: String
  recipient: String
  start: numeric
  status: vestingstatus
  streamingPaymentProcessor_id: String
  token_id: String
}

"""
order by sum() on columns of table "LinearVesting"
"""
input LinearVesting_sum_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by var_pop() on columns of table "LinearVesting"
"""
input LinearVesting_var_pop_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by var_samp() on columns of table "LinearVesting"
"""
input LinearVesting_var_samp_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
order by variance() on columns of table "LinearVesting"
"""
input LinearVesting_variance_order_by {
  amount: order_by
  blockTimestamp: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
}

"""
columns and relationships of "ProjectFee"
"""
type ProjectFee {
  amount: numeric!
  amountUSD: numeric!
  blockTimestamp: Int!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  module_id: String!
  recipient: String!

  """An object relationship"""
  token: Token
  token_id: String!
}

"""
order by aggregate values of table "ProjectFee"
"""
input ProjectFee_aggregate_order_by {
  avg: ProjectFee_avg_order_by
  count: order_by
  max: ProjectFee_max_order_by
  min: ProjectFee_min_order_by
  stddev: ProjectFee_stddev_order_by
  stddev_pop: ProjectFee_stddev_pop_order_by
  stddev_samp: ProjectFee_stddev_samp_order_by
  sum: ProjectFee_sum_order_by
  var_pop: ProjectFee_var_pop_order_by
  var_samp: ProjectFee_var_samp_order_by
  variance: ProjectFee_variance_order_by
}

"""
order by avg() on columns of table "ProjectFee"
"""
input ProjectFee_avg_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
Boolean expression to filter rows from the table "ProjectFee". All fields are combined with a logical 'AND'.
"""
input ProjectFee_bool_exp {
  _and: [ProjectFee_bool_exp!]
  _not: ProjectFee_bool_exp
  _or: [ProjectFee_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  module_id: String_comparison_exp
  recipient: String_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
}

"""
order by max() on columns of table "ProjectFee"
"""
input ProjectFee_max_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  recipient: order_by
  token_id: order_by
}

"""
order by min() on columns of table "ProjectFee"
"""
input ProjectFee_min_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  recipient: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "ProjectFee"."""
input ProjectFee_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  recipient: order_by
  token: Token_order_by
  token_id: order_by
}

"""
select columns of table "ProjectFee"
"""
enum ProjectFee_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  blockTimestamp

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  module_id

  """column name"""
  recipient

  """column name"""
  token_id
}

"""
order by stddev() on columns of table "ProjectFee"
"""
input ProjectFee_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by stddev_pop() on columns of table "ProjectFee"
"""
input ProjectFee_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by stddev_samp() on columns of table "ProjectFee"
"""
input ProjectFee_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
Streaming cursor of the table "ProjectFee"
"""
input ProjectFee_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ProjectFee_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ProjectFee_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  blockTimestamp: Int
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  recipient: String
  token_id: String
}

"""
order by sum() on columns of table "ProjectFee"
"""
input ProjectFee_sum_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by var_pop() on columns of table "ProjectFee"
"""
input ProjectFee_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by var_samp() on columns of table "ProjectFee"
"""
input ProjectFee_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by variance() on columns of table "ProjectFee"
"""
input ProjectFee_variance_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
columns and relationships of "ProtocolFee"
"""
type ProtocolFee {
  amount: numeric!
  amountUSD: numeric!
  blockTimestamp: Int!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  module_id: String!
  source: feesource!

  """An object relationship"""
  token: Token
  token_id: String!
  treasury: String!
}

"""
order by aggregate values of table "ProtocolFee"
"""
input ProtocolFee_aggregate_order_by {
  avg: ProtocolFee_avg_order_by
  count: order_by
  max: ProtocolFee_max_order_by
  min: ProtocolFee_min_order_by
  stddev: ProtocolFee_stddev_order_by
  stddev_pop: ProtocolFee_stddev_pop_order_by
  stddev_samp: ProtocolFee_stddev_samp_order_by
  sum: ProtocolFee_sum_order_by
  var_pop: ProtocolFee_var_pop_order_by
  var_samp: ProtocolFee_var_samp_order_by
  variance: ProtocolFee_variance_order_by
}

"""
order by avg() on columns of table "ProtocolFee"
"""
input ProtocolFee_avg_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
Boolean expression to filter rows from the table "ProtocolFee". All fields are combined with a logical 'AND'.
"""
input ProtocolFee_bool_exp {
  _and: [ProtocolFee_bool_exp!]
  _not: ProtocolFee_bool_exp
  _or: [ProtocolFee_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  module_id: String_comparison_exp
  source: feesource_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  treasury: String_comparison_exp
}

"""
order by max() on columns of table "ProtocolFee"
"""
input ProtocolFee_max_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  source: order_by
  token_id: order_by
  treasury: order_by
}

"""
order by min() on columns of table "ProtocolFee"
"""
input ProtocolFee_min_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  source: order_by
  token_id: order_by
  treasury: order_by
}

"""Ordering options when selecting data from "ProtocolFee"."""
input ProtocolFee_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  source: order_by
  token: Token_order_by
  token_id: order_by
  treasury: order_by
}

"""
select columns of table "ProtocolFee"
"""
enum ProtocolFee_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  blockTimestamp

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  module_id

  """column name"""
  source

  """column name"""
  token_id

  """column name"""
  treasury
}

"""
order by stddev() on columns of table "ProtocolFee"
"""
input ProtocolFee_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by stddev_pop() on columns of table "ProtocolFee"
"""
input ProtocolFee_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by stddev_samp() on columns of table "ProtocolFee"
"""
input ProtocolFee_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
Streaming cursor of the table "ProtocolFee"
"""
input ProtocolFee_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ProtocolFee_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ProtocolFee_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  blockTimestamp: Int
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  source: feesource
  token_id: String
  treasury: String
}

"""
order by sum() on columns of table "ProtocolFee"
"""
input ProtocolFee_sum_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by var_pop() on columns of table "ProtocolFee"
"""
input ProtocolFee_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by var_samp() on columns of table "ProtocolFee"
"""
input ProtocolFee_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
order by variance() on columns of table "ProtocolFee"
"""
input ProtocolFee_variance_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
}

"""
columns and relationships of "StreamingPaymentProcessor"
"""
type StreamingPaymentProcessor {
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An array relationship"""
  vestings(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "StreamingPaymentProcessor". All fields are combined with a logical 'AND'.
"""
input StreamingPaymentProcessor_bool_exp {
  _and: [StreamingPaymentProcessor_bool_exp!]
  _not: StreamingPaymentProcessor_bool_exp
  _or: [StreamingPaymentProcessor_bool_exp!]
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  vestings: LinearVesting_bool_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "StreamingPaymentProcessor"."""
input StreamingPaymentProcessor_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  vestings_aggregate: LinearVesting_aggregate_order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "StreamingPaymentProcessor"
"""
enum StreamingPaymentProcessor_select_column {
  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "StreamingPaymentProcessor"
"""
input StreamingPaymentProcessor_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: StreamingPaymentProcessor_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input StreamingPaymentProcessor_stream_cursor_value_input {
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  workflow_id: String
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "Swap"
"""
type Swap {
  amountCOL: numeric!
  amountISS: numeric!
  amountUSD: numeric!
  blockTimestamp: Int!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  db_write_timestamp: timestamp
  id: String!
  initiator: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!
  module_id: String!
  priceCOL: numeric!
  priceUSD: numeric!
  recipient: String!
  swapType: swaptype!
}

"""
order by aggregate values of table "Swap"
"""
input Swap_aggregate_order_by {
  avg: Swap_avg_order_by
  count: order_by
  max: Swap_max_order_by
  min: Swap_min_order_by
  stddev: Swap_stddev_order_by
  stddev_pop: Swap_stddev_pop_order_by
  stddev_samp: Swap_stddev_samp_order_by
  sum: Swap_sum_order_by
  var_pop: Swap_var_pop_order_by
  var_samp: Swap_var_samp_order_by
  variance: Swap_variance_order_by
}

"""
order by avg() on columns of table "Swap"
"""
input Swap_avg_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
Boolean expression to filter rows from the table "Swap". All fields are combined with a logical 'AND'.
"""
input Swap_bool_exp {
  _and: [Swap_bool_exp!]
  _not: Swap_bool_exp
  _or: [Swap_bool_exp!]
  amountCOL: numeric_comparison_exp
  amountISS: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  initiator: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  module_id: String_comparison_exp
  priceCOL: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  recipient: String_comparison_exp
  swapType: swaptype_comparison_exp
}

"""
order by max() on columns of table "Swap"
"""
input Swap_max_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  issuanceToken_id: order_by
  module_id: order_by
  priceCOL: order_by
  priceUSD: order_by
  recipient: order_by
  swapType: order_by
}

"""
order by min() on columns of table "Swap"
"""
input Swap_min_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  issuanceToken_id: order_by
  module_id: order_by
  priceCOL: order_by
  priceUSD: order_by
  recipient: order_by
  swapType: order_by
}

"""Ordering options when selecting data from "Swap"."""
input Swap_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  module_id: order_by
  priceCOL: order_by
  priceUSD: order_by
  recipient: order_by
  swapType: order_by
}

"""
select columns of table "Swap"
"""
enum Swap_select_column {
  """column name"""
  amountCOL

  """column name"""
  amountISS

  """column name"""
  amountUSD

  """column name"""
  blockTimestamp

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  issuanceToken_id

  """column name"""
  module_id

  """column name"""
  priceCOL

  """column name"""
  priceUSD

  """column name"""
  recipient

  """column name"""
  swapType
}

"""
order by stddev() on columns of table "Swap"
"""
input Swap_stddev_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
order by stddev_pop() on columns of table "Swap"
"""
input Swap_stddev_pop_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
order by stddev_samp() on columns of table "Swap"
"""
input Swap_stddev_samp_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
Streaming cursor of the table "Swap"
"""
input Swap_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Swap_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Swap_stream_cursor_value_input {
  amountCOL: numeric
  amountISS: numeric
  amountUSD: numeric
  blockTimestamp: Int
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  id: String
  initiator: String
  issuanceToken_id: String
  module_id: String
  priceCOL: numeric
  priceUSD: numeric
  recipient: String
  swapType: swaptype
}

"""
order by sum() on columns of table "Swap"
"""
input Swap_sum_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
order by var_pop() on columns of table "Swap"
"""
input Swap_var_pop_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
order by var_samp() on columns of table "Swap"
"""
input Swap_var_samp_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
order by variance() on columns of table "Swap"
"""
input Swap_variance_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
}

"""
columns and relationships of "Token"
"""
type Token {
  address: String!
  chainId: Int!
  db_write_timestamp: timestamp
  decimals: Int!
  id: String!
  name: String!
  priceUSD: numeric!
  symbol: String!
  totalSupply: numeric!
}

"""
Boolean expression to filter rows from the table "Token". All fields are combined with a logical 'AND'.
"""
input Token_bool_exp {
  _and: [Token_bool_exp!]
  _not: Token_bool_exp
  _or: [Token_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  decimals: Int_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  priceUSD: numeric_comparison_exp
  symbol: String_comparison_exp
  totalSupply: numeric_comparison_exp
}

"""Ordering options when selecting data from "Token"."""
input Token_order_by {
  address: order_by
  chainId: order_by
  db_write_timestamp: order_by
  decimals: order_by
  id: order_by
  name: order_by
  priceUSD: order_by
  symbol: order_by
  totalSupply: order_by
}

"""
select columns of table "Token"
"""
enum Token_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  decimals

  """column name"""
  id

  """column name"""
  name

  """column name"""
  priceUSD

  """column name"""
  symbol

  """column name"""
  totalSupply
}

"""
Streaming cursor of the table "Token"
"""
input Token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Token_stream_cursor_value_input {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  decimals: Int
  id: String
  name: String
  priceUSD: numeric
  symbol: String
  totalSupply: numeric
}

"""
columns and relationships of "Transfer"
"""
type Transfer {
  amount: numeric!
  amountUSD: numeric!
  blockTimestamp: Int!
  db_write_timestamp: timestamp

  """An object relationship"""
  depositVault: DepositVault
  depositVault_id: String!
  id: String!
  recipient: String!
}

"""
order by aggregate values of table "Transfer"
"""
input Transfer_aggregate_order_by {
  avg: Transfer_avg_order_by
  count: order_by
  max: Transfer_max_order_by
  min: Transfer_min_order_by
  stddev: Transfer_stddev_order_by
  stddev_pop: Transfer_stddev_pop_order_by
  stddev_samp: Transfer_stddev_samp_order_by
  sum: Transfer_sum_order_by
  var_pop: Transfer_var_pop_order_by
  var_samp: Transfer_var_samp_order_by
  variance: Transfer_variance_order_by
}

"""
order by avg() on columns of table "Transfer"
"""
input Transfer_avg_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
Boolean expression to filter rows from the table "Transfer". All fields are combined with a logical 'AND'.
"""
input Transfer_bool_exp {
  _and: [Transfer_bool_exp!]
  _not: Transfer_bool_exp
  _or: [Transfer_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  blockTimestamp: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  depositVault: DepositVault_bool_exp
  depositVault_id: String_comparison_exp
  id: String_comparison_exp
  recipient: String_comparison_exp
}

"""
order by max() on columns of table "Transfer"
"""
input Transfer_max_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  id: order_by
  recipient: order_by
}

"""
order by min() on columns of table "Transfer"
"""
input Transfer_min_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  id: order_by
  recipient: order_by
}

"""Ordering options when selecting data from "Transfer"."""
input Transfer_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
  db_write_timestamp: order_by
  depositVault: DepositVault_order_by
  depositVault_id: order_by
  id: order_by
  recipient: order_by
}

"""
select columns of table "Transfer"
"""
enum Transfer_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  blockTimestamp

  """column name"""
  db_write_timestamp

  """column name"""
  depositVault_id

  """column name"""
  id

  """column name"""
  recipient
}

"""
order by stddev() on columns of table "Transfer"
"""
input Transfer_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by stddev_pop() on columns of table "Transfer"
"""
input Transfer_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by stddev_samp() on columns of table "Transfer"
"""
input Transfer_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
Streaming cursor of the table "Transfer"
"""
input Transfer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Transfer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Transfer_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  blockTimestamp: Int
  db_write_timestamp: timestamp
  depositVault_id: String
  id: String
  recipient: String
}

"""
order by sum() on columns of table "Transfer"
"""
input Transfer_sum_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by var_pop() on columns of table "Transfer"
"""
input Transfer_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by var_samp() on columns of table "Transfer"
"""
input Transfer_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
order by variance() on columns of table "Transfer"
"""
input Transfer_variance_order_by {
  amount: order_by
  amountUSD: order_by
  blockTimestamp: order_by
}

"""
columns and relationships of "Workflow"
"""
type Workflow {
  """An object relationship"""
  authorizer: WorkflowModule
  authorizer_id: String!
  chainId: Int!
  db_write_timestamp: timestamp

  """An object relationship"""
  fundingManager: WorkflowModule
  fundingManager_id: String!
  id: String!
  optionalModules: [String!]
  orchestrator: String!

  """An object relationship"""
  paymentProcessor: WorkflowModule
  paymentProcessor_id: String!
}

"""
columns and relationships of "WorkflowModule"
"""
type WorkflowModule {
  address: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An object relationship"""
  moduleType: WorkflowModuleType
  moduleType_id: String!
  orchestrator: String!
}

"""
columns and relationships of "WorkflowModuleType"
"""
type WorkflowModuleType {
  beacon: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  majorVersion: numeric!
  minorVersion: numeric!
  name: String!
  patchVersion: numeric!
  url: String!
}

"""
Boolean expression to filter rows from the table "WorkflowModuleType". All fields are combined with a logical 'AND'.
"""
input WorkflowModuleType_bool_exp {
  _and: [WorkflowModuleType_bool_exp!]
  _not: WorkflowModuleType_bool_exp
  _or: [WorkflowModuleType_bool_exp!]
  beacon: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  majorVersion: numeric_comparison_exp
  minorVersion: numeric_comparison_exp
  name: String_comparison_exp
  patchVersion: numeric_comparison_exp
  url: String_comparison_exp
}

"""Ordering options when selecting data from "WorkflowModuleType"."""
input WorkflowModuleType_order_by {
  beacon: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  majorVersion: order_by
  minorVersion: order_by
  name: order_by
  patchVersion: order_by
  url: order_by
}

"""
select columns of table "WorkflowModuleType"
"""
enum WorkflowModuleType_select_column {
  """column name"""
  beacon

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  majorVersion

  """column name"""
  minorVersion

  """column name"""
  name

  """column name"""
  patchVersion

  """column name"""
  url
}

"""
Streaming cursor of the table "WorkflowModuleType"
"""
input WorkflowModuleType_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: WorkflowModuleType_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input WorkflowModuleType_stream_cursor_value_input {
  beacon: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  majorVersion: numeric
  minorVersion: numeric
  name: String
  patchVersion: numeric
  url: String
}

"""
Boolean expression to filter rows from the table "WorkflowModule". All fields are combined with a logical 'AND'.
"""
input WorkflowModule_bool_exp {
  _and: [WorkflowModule_bool_exp!]
  _not: WorkflowModule_bool_exp
  _or: [WorkflowModule_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  moduleType: WorkflowModuleType_bool_exp
  moduleType_id: String_comparison_exp
  orchestrator: String_comparison_exp
}

"""Ordering options when selecting data from "WorkflowModule"."""
input WorkflowModule_order_by {
  address: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  moduleType: WorkflowModuleType_order_by
  moduleType_id: order_by
  orchestrator: order_by
}

"""
select columns of table "WorkflowModule"
"""
enum WorkflowModule_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  moduleType_id

  """column name"""
  orchestrator
}

"""
Streaming cursor of the table "WorkflowModule"
"""
input WorkflowModule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: WorkflowModule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input WorkflowModule_stream_cursor_value_input {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  moduleType_id: String
  orchestrator: String
}

"""
Boolean expression to filter rows from the table "Workflow". All fields are combined with a logical 'AND'.
"""
input Workflow_bool_exp {
  _and: [Workflow_bool_exp!]
  _not: Workflow_bool_exp
  _or: [Workflow_bool_exp!]
  authorizer: WorkflowModule_bool_exp
  authorizer_id: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  fundingManager: WorkflowModule_bool_exp
  fundingManager_id: String_comparison_exp
  id: String_comparison_exp
  optionalModules: String_array_comparison_exp
  orchestrator: String_comparison_exp
  paymentProcessor: WorkflowModule_bool_exp
  paymentProcessor_id: String_comparison_exp
}

"""Ordering options when selecting data from "Workflow"."""
input Workflow_order_by {
  authorizer: WorkflowModule_order_by
  authorizer_id: order_by
  chainId: order_by
  db_write_timestamp: order_by
  fundingManager: WorkflowModule_order_by
  fundingManager_id: order_by
  id: order_by
  optionalModules: order_by
  orchestrator: order_by
  paymentProcessor: WorkflowModule_order_by
  paymentProcessor_id: order_by
}

"""
select columns of table "Workflow"
"""
enum Workflow_select_column {
  """column name"""
  authorizer_id

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  fundingManager_id

  """column name"""
  id

  """column name"""
  optionalModules

  """column name"""
  orchestrator

  """column name"""
  paymentProcessor_id
}

"""
Streaming cursor of the table "Workflow"
"""
input Workflow_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Workflow_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Workflow_stream_cursor_value_input {
  authorizer_id: String
  chainId: Int
  db_write_timestamp: timestamp
  fundingManager_id: String
  id: String
  optionalModules: [String!]
  orchestrator: String
  paymentProcessor_id: String
}

"""
columns and relationships of "chain_metadata"
"""
type chain_metadata {
  block_height: Int!
  chain_id: Int!
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean!
  latest_fetched_block_number: Int!
  latest_processed_block: Int
  num_batches_fetched: Int!
  num_events_processed: Int
  start_block: Int!
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

"""
Boolean expression to filter rows from the table "chain_metadata". All fields are combined with a logical 'AND'.
"""
input chain_metadata_bool_exp {
  _and: [chain_metadata_bool_exp!]
  _not: chain_metadata_bool_exp
  _or: [chain_metadata_bool_exp!]
  block_height: Int_comparison_exp
  chain_id: Int_comparison_exp
  end_block: Int_comparison_exp
  first_event_block_number: Int_comparison_exp
  is_hyper_sync: Boolean_comparison_exp
  latest_fetched_block_number: Int_comparison_exp
  latest_processed_block: Int_comparison_exp
  num_batches_fetched: Int_comparison_exp
  num_events_processed: Int_comparison_exp
  start_block: Int_comparison_exp
  timestamp_caught_up_to_head_or_endblock: timestamptz_comparison_exp
}

"""Ordering options when selecting data from "chain_metadata"."""
input chain_metadata_order_by {
  block_height: order_by
  chain_id: order_by
  end_block: order_by
  first_event_block_number: order_by
  is_hyper_sync: order_by
  latest_fetched_block_number: order_by
  latest_processed_block: order_by
  num_batches_fetched: order_by
  num_events_processed: order_by
  start_block: order_by
  timestamp_caught_up_to_head_or_endblock: order_by
}

"""
select columns of table "chain_metadata"
"""
enum chain_metadata_select_column {
  """column name"""
  block_height

  """column name"""
  chain_id

  """column name"""
  end_block

  """column name"""
  first_event_block_number

  """column name"""
  is_hyper_sync

  """column name"""
  latest_fetched_block_number

  """column name"""
  latest_processed_block

  """column name"""
  num_batches_fetched

  """column name"""
  num_events_processed

  """column name"""
  start_block

  """column name"""
  timestamp_caught_up_to_head_or_endblock
}

"""
Streaming cursor of the table "chain_metadata"
"""
input chain_metadata_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chain_metadata_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chain_metadata_stream_cursor_value_input {
  block_height: Int
  chain_id: Int
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean
  latest_fetched_block_number: Int
  latest_processed_block: Int
  num_batches_fetched: Int
  num_events_processed: Int
  start_block: Int
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

scalar contract_type

"""
Boolean expression to compare columns of type "contract_type". All fields are combined with logical 'AND'.
"""
input contract_type_comparison_exp {
  _eq: contract_type
  _gt: contract_type
  _gte: contract_type
  _in: [contract_type!]
  _is_null: Boolean
  _lt: contract_type
  _lte: contract_type
  _neq: contract_type
  _nin: [contract_type!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "dynamic_contract_registry"
"""
type dynamic_contract_registry {
  chain_id: Int!
  contract_address: String!
  contract_type: contract_type!
  id: String!
  is_pre_registered: Boolean!
  registering_event_block_number: Int!
  registering_event_block_timestamp: Int!
  registering_event_contract_name: String!
  registering_event_log_index: Int!
  registering_event_name: String!
  registering_event_src_address: String!
}

"""
Boolean expression to filter rows from the table "dynamic_contract_registry". All fields are combined with a logical 'AND'.
"""
input dynamic_contract_registry_bool_exp {
  _and: [dynamic_contract_registry_bool_exp!]
  _not: dynamic_contract_registry_bool_exp
  _or: [dynamic_contract_registry_bool_exp!]
  chain_id: Int_comparison_exp
  contract_address: String_comparison_exp
  contract_type: contract_type_comparison_exp
  id: String_comparison_exp
  is_pre_registered: Boolean_comparison_exp
  registering_event_block_number: Int_comparison_exp
  registering_event_block_timestamp: Int_comparison_exp
  registering_event_contract_name: String_comparison_exp
  registering_event_log_index: Int_comparison_exp
  registering_event_name: String_comparison_exp
  registering_event_src_address: String_comparison_exp
}

"""Ordering options when selecting data from "dynamic_contract_registry"."""
input dynamic_contract_registry_order_by {
  chain_id: order_by
  contract_address: order_by
  contract_type: order_by
  id: order_by
  is_pre_registered: order_by
  registering_event_block_number: order_by
  registering_event_block_timestamp: order_by
  registering_event_contract_name: order_by
  registering_event_log_index: order_by
  registering_event_name: order_by
  registering_event_src_address: order_by
}

"""
select columns of table "dynamic_contract_registry"
"""
enum dynamic_contract_registry_select_column {
  """column name"""
  chain_id

  """column name"""
  contract_address

  """column name"""
  contract_type

  """column name"""
  id

  """column name"""
  is_pre_registered

  """column name"""
  registering_event_block_number

  """column name"""
  registering_event_block_timestamp

  """column name"""
  registering_event_contract_name

  """column name"""
  registering_event_log_index

  """column name"""
  registering_event_name

  """column name"""
  registering_event_src_address
}

"""
Streaming cursor of the table "dynamic_contract_registry"
"""
input dynamic_contract_registry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: dynamic_contract_registry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input dynamic_contract_registry_stream_cursor_value_input {
  chain_id: Int
  contract_address: String
  contract_type: contract_type
  id: String
  is_pre_registered: Boolean
  registering_event_block_number: Int
  registering_event_block_timestamp: Int
  registering_event_contract_name: String
  registering_event_log_index: Int
  registering_event_name: String
  registering_event_src_address: String
}

"""
columns and relationships of "end_of_block_range_scanned_data"
"""
type end_of_block_range_scanned_data {
  block_hash: String!
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
}

"""
Boolean expression to filter rows from the table "end_of_block_range_scanned_data". All fields are combined with a logical 'AND'.
"""
input end_of_block_range_scanned_data_bool_exp {
  _and: [end_of_block_range_scanned_data_bool_exp!]
  _not: end_of_block_range_scanned_data_bool_exp
  _or: [end_of_block_range_scanned_data_bool_exp!]
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
}

"""
Ordering options when selecting data from "end_of_block_range_scanned_data".
"""
input end_of_block_range_scanned_data_order_by {
  block_hash: order_by
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
}

"""
select columns of table "end_of_block_range_scanned_data"
"""
enum end_of_block_range_scanned_data_select_column {
  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id
}

"""
Streaming cursor of the table "end_of_block_range_scanned_data"
"""
input end_of_block_range_scanned_data_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: end_of_block_range_scanned_data_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input end_of_block_range_scanned_data_stream_cursor_value_input {
  block_hash: String
  block_number: Int
  block_timestamp: Int
  chain_id: Int
}

"""
columns and relationships of "event_sync_state"
"""
type event_sync_state {
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  is_pre_registering_dynamic_contracts: Boolean!
  log_index: Int!
}

"""
Boolean expression to filter rows from the table "event_sync_state". All fields are combined with a logical 'AND'.
"""
input event_sync_state_bool_exp {
  _and: [event_sync_state_bool_exp!]
  _not: event_sync_state_bool_exp
  _or: [event_sync_state_bool_exp!]
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  is_pre_registering_dynamic_contracts: Boolean_comparison_exp
  log_index: Int_comparison_exp
}

"""Ordering options when selecting data from "event_sync_state"."""
input event_sync_state_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  is_pre_registering_dynamic_contracts: order_by
  log_index: order_by
}

"""
select columns of table "event_sync_state"
"""
enum event_sync_state_select_column {
  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  is_pre_registering_dynamic_contracts

  """column name"""
  log_index
}

"""
Streaming cursor of the table "event_sync_state"
"""
input event_sync_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: event_sync_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input event_sync_state_stream_cursor_value_input {
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  is_pre_registering_dynamic_contracts: Boolean
  log_index: Int
}

scalar feesource

"""
Boolean expression to compare columns of type "feesource". All fields are combined with logical 'AND'.
"""
input feesource_comparison_exp {
  _eq: feesource
  _gt: feesource
  _gte: feesource
  _in: [feesource!]
  _is_null: Boolean
  _lt: feesource
  _lte: feesource
  _neq: feesource
  _nin: [feesource!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "persisted_state"
"""
type persisted_state {
  abi_files_hash: String!
  config_hash: String!
  envio_version: String!
  handler_files_hash: String!
  id: Int!
  schema_hash: String!
}

"""
Boolean expression to filter rows from the table "persisted_state". All fields are combined with a logical 'AND'.
"""
input persisted_state_bool_exp {
  _and: [persisted_state_bool_exp!]
  _not: persisted_state_bool_exp
  _or: [persisted_state_bool_exp!]
  abi_files_hash: String_comparison_exp
  config_hash: String_comparison_exp
  envio_version: String_comparison_exp
  handler_files_hash: String_comparison_exp
  id: Int_comparison_exp
  schema_hash: String_comparison_exp
}

"""Ordering options when selecting data from "persisted_state"."""
input persisted_state_order_by {
  abi_files_hash: order_by
  config_hash: order_by
  envio_version: order_by
  handler_files_hash: order_by
  id: order_by
  schema_hash: order_by
}

"""
select columns of table "persisted_state"
"""
enum persisted_state_select_column {
  """column name"""
  abi_files_hash

  """column name"""
  config_hash

  """column name"""
  envio_version

  """column name"""
  handler_files_hash

  """column name"""
  id

  """column name"""
  schema_hash
}

"""
Streaming cursor of the table "persisted_state"
"""
input persisted_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: persisted_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input persisted_state_stream_cursor_value_input {
  abi_files_hash: String
  config_hash: String
  envio_version: String
  handler_files_hash: String
  id: Int
  schema_hash: String
}

type query_root {
  """
  fetch data from the table: "BondingCurve"
  """
  BondingCurve(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """fetch data from the table: "BondingCurve" using primary key columns"""
  BondingCurve_by_pk(id: String!): BondingCurve

  """
  fetch data from the table: "Bounty"
  """
  Bounty(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!

  """
  fetch data from the table: "BountyClaim"
  """
  BountyClaim(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!

  """fetch data from the table: "BountyClaim" using primary key columns"""
  BountyClaim_by_pk(id: String!): BountyClaim

  """
  fetch data from the table: "BountyContributor"
  """
  BountyContributor(
    """distinct select on columns"""
    distinct_on: [BountyContributor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyContributor_order_by!]

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!

  """
  fetch data from the table: "BountyContributor" using primary key columns
  """
  BountyContributor_by_pk(id: String!): BountyContributor

  """
  fetch data from the table: "BountyModule"
  """
  BountyModule(
    """distinct select on columns"""
    distinct_on: [BountyModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyModule_order_by!]

    """filter the rows returned"""
    where: BountyModule_bool_exp
  ): [BountyModule!]!

  """fetch data from the table: "BountyModule" using primary key columns"""
  BountyModule_by_pk(id: String!): BountyModule

  """fetch data from the table: "Bounty" using primary key columns"""
  Bounty_by_pk(id: String!): Bounty

  """
  fetch data from the table: "CurveDayData"
  """
  CurveDayData(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """fetch data from the table: "CurveDayData" using primary key columns"""
  CurveDayData_by_pk(id: String!): CurveDayData

  """
  fetch data from the table: "CurveHourData"
  """
  CurveHourData(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """fetch data from the table: "CurveHourData" using primary key columns"""
  CurveHourData_by_pk(id: String!): CurveHourData

  """
  fetch data from the table: "Deposit"
  """
  Deposit(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!

  """
  fetch data from the table: "DepositVault"
  """
  DepositVault(
    """distinct select on columns"""
    distinct_on: [DepositVault_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DepositVault_order_by!]

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): [DepositVault!]!

  """fetch data from the table: "DepositVault" using primary key columns"""
  DepositVault_by_pk(id: String!): DepositVault

  """fetch data from the table: "Deposit" using primary key columns"""
  Deposit_by_pk(id: String!): Deposit

  """
  fetch data from the table: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """
  fetch data from the table: "IssuanceTokenDayData" using primary key columns
  """
  IssuanceTokenDayData_by_pk(id: String!): IssuanceTokenDayData

  """
  fetch data from the table: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """
  fetch data from the table: "IssuanceTokenHourData" using primary key columns
  """
  IssuanceTokenHourData_by_pk(id: String!): IssuanceTokenHourData

  """
  fetch data from the table: "LinearVesting"
  """
  LinearVesting(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """fetch data from the table: "LinearVesting" using primary key columns"""
  LinearVesting_by_pk(id: String!): LinearVesting

  """
  fetch data from the table: "ProjectFee"
  """
  ProjectFee(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """fetch data from the table: "ProjectFee" using primary key columns"""
  ProjectFee_by_pk(id: String!): ProjectFee

  """
  fetch data from the table: "ProtocolFee"
  """
  ProtocolFee(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """fetch data from the table: "ProtocolFee" using primary key columns"""
  ProtocolFee_by_pk(id: String!): ProtocolFee

  """
  fetch data from the table: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor(
    """distinct select on columns"""
    distinct_on: [StreamingPaymentProcessor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StreamingPaymentProcessor_order_by!]

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "StreamingPaymentProcessor" using primary key columns
  """
  StreamingPaymentProcessor_by_pk(id: String!): StreamingPaymentProcessor

  """
  fetch data from the table: "Swap"
  """
  Swap(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """fetch data from the table: "Swap" using primary key columns"""
  Swap_by_pk(id: String!): Swap

  """
  fetch data from the table: "Token"
  """
  Token(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """fetch data from the table: "Token" using primary key columns"""
  Token_by_pk(id: String!): Token

  """
  fetch data from the table: "Transfer"
  """
  Transfer(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """fetch data from the table: "Transfer" using primary key columns"""
  Transfer_by_pk(id: String!): Transfer

  """
  fetch data from the table: "Workflow"
  """
  Workflow(
    """distinct select on columns"""
    distinct_on: [Workflow_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Workflow_order_by!]

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "WorkflowModule"
  """
  WorkflowModule(
    """distinct select on columns"""
    distinct_on: [WorkflowModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModule_order_by!]

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """
  fetch data from the table: "WorkflowModuleType"
  """
  WorkflowModuleType(
    """distinct select on columns"""
    distinct_on: [WorkflowModuleType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModuleType_order_by!]

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """
  fetch data from the table: "WorkflowModuleType" using primary key columns
  """
  WorkflowModuleType_by_pk(id: String!): WorkflowModuleType

  """fetch data from the table: "WorkflowModule" using primary key columns"""
  WorkflowModule_by_pk(id: String!): WorkflowModule

  """fetch data from the table: "Workflow" using primary key columns"""
  Workflow_by_pk(id: String!): Workflow

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(id: String!): dynamic_contract_registry

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(serial: Int!): raw_events
}

"""
columns and relationships of "raw_events"
"""
type raw_events {
  block_fields(
    """JSON select path"""
    path: String
  ): jsonb!
  block_hash: String!
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  contract_name: String!
  db_write_timestamp: timestamp
  event_id: numeric!
  event_name: String!
  log_index: Int!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
  serial: Int!
  src_address: String!
  transaction_fields(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
Boolean expression to filter rows from the table "raw_events". All fields are combined with a logical 'AND'.
"""
input raw_events_bool_exp {
  _and: [raw_events_bool_exp!]
  _not: raw_events_bool_exp
  _or: [raw_events_bool_exp!]
  block_fields: jsonb_comparison_exp
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  contract_name: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  event_id: numeric_comparison_exp
  event_name: String_comparison_exp
  log_index: Int_comparison_exp
  params: jsonb_comparison_exp
  serial: Int_comparison_exp
  src_address: String_comparison_exp
  transaction_fields: jsonb_comparison_exp
}

"""Ordering options when selecting data from "raw_events"."""
input raw_events_order_by {
  block_fields: order_by
  block_hash: order_by
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  contract_name: order_by
  db_write_timestamp: order_by
  event_id: order_by
  event_name: order_by
  log_index: order_by
  params: order_by
  serial: order_by
  src_address: order_by
  transaction_fields: order_by
}

"""
select columns of table "raw_events"
"""
enum raw_events_select_column {
  """column name"""
  block_fields

  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  contract_name

  """column name"""
  db_write_timestamp

  """column name"""
  event_id

  """column name"""
  event_name

  """column name"""
  log_index

  """column name"""
  params

  """column name"""
  serial

  """column name"""
  src_address

  """column name"""
  transaction_fields
}

"""
Streaming cursor of the table "raw_events"
"""
input raw_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: raw_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input raw_events_stream_cursor_value_input {
  block_fields: jsonb
  block_hash: String
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  contract_name: String
  db_write_timestamp: timestamp
  event_id: numeric
  event_name: String
  log_index: Int
  params: jsonb
  serial: Int
  src_address: String
  transaction_fields: jsonb
}

type subscription_root {
  """
  fetch data from the table: "BondingCurve"
  """
  BondingCurve(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """fetch data from the table: "BondingCurve" using primary key columns"""
  BondingCurve_by_pk(id: String!): BondingCurve

  """
  fetch data from the table in a streaming manner: "BondingCurve"
  """
  BondingCurve_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BondingCurve_stream_cursor_input]!

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """
  fetch data from the table: "Bounty"
  """
  Bounty(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!

  """
  fetch data from the table: "BountyClaim"
  """
  BountyClaim(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!

  """fetch data from the table: "BountyClaim" using primary key columns"""
  BountyClaim_by_pk(id: String!): BountyClaim

  """
  fetch data from the table in a streaming manner: "BountyClaim"
  """
  BountyClaim_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BountyClaim_stream_cursor_input]!

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!

  """
  fetch data from the table: "BountyContributor"
  """
  BountyContributor(
    """distinct select on columns"""
    distinct_on: [BountyContributor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyContributor_order_by!]

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!

  """
  fetch data from the table: "BountyContributor" using primary key columns
  """
  BountyContributor_by_pk(id: String!): BountyContributor

  """
  fetch data from the table in a streaming manner: "BountyContributor"
  """
  BountyContributor_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BountyContributor_stream_cursor_input]!

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!

  """
  fetch data from the table: "BountyModule"
  """
  BountyModule(
    """distinct select on columns"""
    distinct_on: [BountyModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyModule_order_by!]

    """filter the rows returned"""
    where: BountyModule_bool_exp
  ): [BountyModule!]!

  """fetch data from the table: "BountyModule" using primary key columns"""
  BountyModule_by_pk(id: String!): BountyModule

  """
  fetch data from the table in a streaming manner: "BountyModule"
  """
  BountyModule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BountyModule_stream_cursor_input]!

    """filter the rows returned"""
    where: BountyModule_bool_exp
  ): [BountyModule!]!

  """fetch data from the table: "Bounty" using primary key columns"""
  Bounty_by_pk(id: String!): Bounty

  """
  fetch data from the table in a streaming manner: "Bounty"
  """
  Bounty_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Bounty_stream_cursor_input]!

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!

  """
  fetch data from the table: "CurveDayData"
  """
  CurveDayData(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """fetch data from the table: "CurveDayData" using primary key columns"""
  CurveDayData_by_pk(id: String!): CurveDayData

  """
  fetch data from the table in a streaming manner: "CurveDayData"
  """
  CurveDayData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CurveDayData_stream_cursor_input]!

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """
  fetch data from the table: "CurveHourData"
  """
  CurveHourData(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """fetch data from the table: "CurveHourData" using primary key columns"""
  CurveHourData_by_pk(id: String!): CurveHourData

  """
  fetch data from the table in a streaming manner: "CurveHourData"
  """
  CurveHourData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CurveHourData_stream_cursor_input]!

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """
  fetch data from the table: "Deposit"
  """
  Deposit(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!

  """
  fetch data from the table: "DepositVault"
  """
  DepositVault(
    """distinct select on columns"""
    distinct_on: [DepositVault_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DepositVault_order_by!]

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): [DepositVault!]!

  """fetch data from the table: "DepositVault" using primary key columns"""
  DepositVault_by_pk(id: String!): DepositVault

  """
  fetch data from the table in a streaming manner: "DepositVault"
  """
  DepositVault_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DepositVault_stream_cursor_input]!

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): [DepositVault!]!

  """fetch data from the table: "Deposit" using primary key columns"""
  Deposit_by_pk(id: String!): Deposit

  """
  fetch data from the table in a streaming manner: "Deposit"
  """
  Deposit_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Deposit_stream_cursor_input]!

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!

  """
  fetch data from the table: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """
  fetch data from the table: "IssuanceTokenDayData" using primary key columns
  """
  IssuanceTokenDayData_by_pk(id: String!): IssuanceTokenDayData

  """
  fetch data from the table in a streaming manner: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [IssuanceTokenDayData_stream_cursor_input]!

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """
  fetch data from the table: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """
  fetch data from the table: "IssuanceTokenHourData" using primary key columns
  """
  IssuanceTokenHourData_by_pk(id: String!): IssuanceTokenHourData

  """
  fetch data from the table in a streaming manner: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [IssuanceTokenHourData_stream_cursor_input]!

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """
  fetch data from the table: "LinearVesting"
  """
  LinearVesting(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """fetch data from the table: "LinearVesting" using primary key columns"""
  LinearVesting_by_pk(id: String!): LinearVesting

  """
  fetch data from the table in a streaming manner: "LinearVesting"
  """
  LinearVesting_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LinearVesting_stream_cursor_input]!

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """
  fetch data from the table: "ProjectFee"
  """
  ProjectFee(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """fetch data from the table: "ProjectFee" using primary key columns"""
  ProjectFee_by_pk(id: String!): ProjectFee

  """
  fetch data from the table in a streaming manner: "ProjectFee"
  """
  ProjectFee_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProjectFee_stream_cursor_input]!

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """
  fetch data from the table: "ProtocolFee"
  """
  ProtocolFee(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """fetch data from the table: "ProtocolFee" using primary key columns"""
  ProtocolFee_by_pk(id: String!): ProtocolFee

  """
  fetch data from the table in a streaming manner: "ProtocolFee"
  """
  ProtocolFee_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProtocolFee_stream_cursor_input]!

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """
  fetch data from the table: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor(
    """distinct select on columns"""
    distinct_on: [StreamingPaymentProcessor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StreamingPaymentProcessor_order_by!]

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "StreamingPaymentProcessor" using primary key columns
  """
  StreamingPaymentProcessor_by_pk(id: String!): StreamingPaymentProcessor

  """
  fetch data from the table in a streaming manner: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [StreamingPaymentProcessor_stream_cursor_input]!

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "Swap"
  """
  Swap(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """fetch data from the table: "Swap" using primary key columns"""
  Swap_by_pk(id: String!): Swap

  """
  fetch data from the table in a streaming manner: "Swap"
  """
  Swap_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Swap_stream_cursor_input]!

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """
  fetch data from the table: "Token"
  """
  Token(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """fetch data from the table: "Token" using primary key columns"""
  Token_by_pk(id: String!): Token

  """
  fetch data from the table in a streaming manner: "Token"
  """
  Token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Token_stream_cursor_input]!

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """
  fetch data from the table: "Transfer"
  """
  Transfer(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """fetch data from the table: "Transfer" using primary key columns"""
  Transfer_by_pk(id: String!): Transfer

  """
  fetch data from the table in a streaming manner: "Transfer"
  """
  Transfer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Transfer_stream_cursor_input]!

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """
  fetch data from the table: "Workflow"
  """
  Workflow(
    """distinct select on columns"""
    distinct_on: [Workflow_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Workflow_order_by!]

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "WorkflowModule"
  """
  WorkflowModule(
    """distinct select on columns"""
    distinct_on: [WorkflowModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModule_order_by!]

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """
  fetch data from the table: "WorkflowModuleType"
  """
  WorkflowModuleType(
    """distinct select on columns"""
    distinct_on: [WorkflowModuleType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModuleType_order_by!]

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """
  fetch data from the table: "WorkflowModuleType" using primary key columns
  """
  WorkflowModuleType_by_pk(id: String!): WorkflowModuleType

  """
  fetch data from the table in a streaming manner: "WorkflowModuleType"
  """
  WorkflowModuleType_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [WorkflowModuleType_stream_cursor_input]!

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """fetch data from the table: "WorkflowModule" using primary key columns"""
  WorkflowModule_by_pk(id: String!): WorkflowModule

  """
  fetch data from the table in a streaming manner: "WorkflowModule"
  """
  WorkflowModule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [WorkflowModule_stream_cursor_input]!

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """fetch data from the table: "Workflow" using primary key columns"""
  Workflow_by_pk(id: String!): Workflow

  """
  fetch data from the table in a streaming manner: "Workflow"
  """
  Workflow_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Workflow_stream_cursor_input]!

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table in a streaming manner: "chain_metadata"
  """
  chain_metadata_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chain_metadata_stream_cursor_input]!

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(id: String!): dynamic_contract_registry

  """
  fetch data from the table in a streaming manner: "dynamic_contract_registry"
  """
  dynamic_contract_registry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [dynamic_contract_registry_stream_cursor_input]!

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table in a streaming manner: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [end_of_block_range_scanned_data_stream_cursor_input]!

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """
  fetch data from the table in a streaming manner: "event_sync_state"
  """
  event_sync_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [event_sync_state_stream_cursor_input]!

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table in a streaming manner: "persisted_state"
  """
  persisted_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [persisted_state_stream_cursor_input]!

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(serial: Int!): raw_events

  """
  fetch data from the table in a streaming manner: "raw_events"
  """
  raw_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [raw_events_stream_cursor_input]!

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!
}

scalar swaptype

"""
Boolean expression to compare columns of type "swaptype". All fields are combined with logical 'AND'.
"""
input swaptype_comparison_exp {
  _eq: swaptype
  _gt: swaptype
  _gte: swaptype
  _in: [swaptype!]
  _is_null: Boolean
  _lt: swaptype
  _lte: swaptype
  _neq: swaptype
  _nin: [swaptype!]
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar vestingstatus

"""
Boolean expression to compare columns of type "vestingstatus". All fields are combined with logical 'AND'.
"""
input vestingstatus_comparison_exp {
  _eq: vestingstatus
  _gt: vestingstatus
  _gte: vestingstatus
  _in: [vestingstatus!]
  _is_null: Boolean
  _lt: vestingstatus
  _lte: vestingstatus
  _neq: vestingstatus
  _nin: [vestingstatus!]
}