schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "AutRoles"
"""
type AutRoles {
  address: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [Role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Role_order_by!]

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "AutRoles". All fields are combined with a logical 'AND'.
"""
input AutRoles_bool_exp {
  _and: [AutRoles_bool_exp!]
  _not: AutRoles_bool_exp
  _or: [AutRoles_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  roles: Role_bool_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "AutRoles"."""
input AutRoles_order_by {
  address: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  roles_aggregate: Role_aggregate_order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "AutRoles"
"""
enum AutRoles_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "AutRoles"
"""
input AutRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: AutRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input AutRoles_stream_cursor_value_input {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  workflow_id: String
}

"""
columns and relationships of "BondingCurve"
"""
type BondingCurve {
  address: String!
  bcType: String
  buyFee: numeric!
  buyReserveRatio: numeric!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!

  """An array relationship"""
  curveDayData(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """An aggregate relationship"""
  curveDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): CurveDayData_aggregate!

  """An array relationship"""
  curveHourData(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """An aggregate relationship"""
  curveHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): CurveHourData_aggregate!
  db_write_timestamp: timestamp
  id: String!

  """An object relationship"""
  issuanceToken: Token

  """An array relationship"""
  issuanceTokenDayData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """An aggregate relationship"""
  issuanceTokenDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): IssuanceTokenDayData_aggregate!

  """An array relationship"""
  issuanceTokenHourData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """An aggregate relationship"""
  issuanceTokenHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): IssuanceTokenHourData_aggregate!
  issuanceToken_id: String!

  """An array relationship"""
  projectFees(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """An aggregate relationship"""
  projectFees_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): ProjectFee_aggregate!

  """An array relationship"""
  protocolFees(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """An aggregate relationship"""
  protocolFees_aggregate(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): ProtocolFee_aggregate!
  reserveCOL: numeric!
  reserveUSD: numeric!
  sellFee: numeric!
  sellReserveRatio: numeric!

  """An array relationship"""
  swaps(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!
  virtualCOL: numeric!
  virtualISS: numeric!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
aggregated selection of "BondingCurve"
"""
type BondingCurve_aggregate {
  aggregate: BondingCurve_aggregate_fields
  nodes: [BondingCurve!]!
}

"""
aggregate fields of "BondingCurve"
"""
type BondingCurve_aggregate_fields {
  avg: BondingCurve_avg_fields
  count(columns: [BondingCurve_select_column!], distinct: Boolean): Int!
  max: BondingCurve_max_fields
  min: BondingCurve_min_fields
  stddev: BondingCurve_stddev_fields
  stddev_pop: BondingCurve_stddev_pop_fields
  stddev_samp: BondingCurve_stddev_samp_fields
  sum: BondingCurve_sum_fields
  var_pop: BondingCurve_var_pop_fields
  var_samp: BondingCurve_var_samp_fields
  variance: BondingCurve_variance_fields
}

"""aggregate avg on columns"""
type BondingCurve_avg_fields {
  buyFee: Float
  buyReserveRatio: Float
  chainId: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
  sellReserveRatio: Float
  virtualCOL: Float
  virtualISS: Float
}

"""
Boolean expression to filter rows from the table "BondingCurve". All fields are combined with a logical 'AND'.
"""
input BondingCurve_bool_exp {
  _and: [BondingCurve_bool_exp!]
  _not: BondingCurve_bool_exp
  _or: [BondingCurve_bool_exp!]
  address: String_comparison_exp
  bcType: String_comparison_exp
  buyFee: numeric_comparison_exp
  buyReserveRatio: numeric_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  curveDayData: CurveDayData_bool_exp
  curveDayData_aggregate: CurveDayData_aggregate_bool_exp
  curveHourData: CurveHourData_bool_exp
  curveHourData_aggregate: CurveHourData_aggregate_bool_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceTokenDayData: IssuanceTokenDayData_bool_exp
  issuanceTokenDayData_aggregate: IssuanceTokenDayData_aggregate_bool_exp
  issuanceTokenHourData: IssuanceTokenHourData_bool_exp
  issuanceTokenHourData_aggregate: IssuanceTokenHourData_aggregate_bool_exp
  issuanceToken_id: String_comparison_exp
  projectFees: ProjectFee_bool_exp
  projectFees_aggregate: ProjectFee_aggregate_bool_exp
  protocolFees: ProtocolFee_bool_exp
  protocolFees_aggregate: ProtocolFee_aggregate_bool_exp
  reserveCOL: numeric_comparison_exp
  reserveUSD: numeric_comparison_exp
  sellFee: numeric_comparison_exp
  sellReserveRatio: numeric_comparison_exp
  swaps: Swap_bool_exp
  virtualCOL: numeric_comparison_exp
  virtualISS: numeric_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""aggregate max on columns"""
type BondingCurve_max_fields {
  address: String
  bcType: String
  buyFee: numeric
  buyReserveRatio: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  id: String
  issuanceToken_id: String
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  sellReserveRatio: numeric
  virtualCOL: numeric
  virtualISS: numeric
  workflow_id: String
}

"""aggregate min on columns"""
type BondingCurve_min_fields {
  address: String
  bcType: String
  buyFee: numeric
  buyReserveRatio: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  id: String
  issuanceToken_id: String
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  sellReserveRatio: numeric
  virtualCOL: numeric
  virtualISS: numeric
  workflow_id: String
}

"""Ordering options when selecting data from "BondingCurve"."""
input BondingCurve_order_by {
  address: order_by
  bcType: order_by
  buyFee: order_by
  buyReserveRatio: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  curveDayData_aggregate: CurveDayData_aggregate_order_by
  curveHourData_aggregate: CurveHourData_aggregate_order_by
  db_write_timestamp: order_by
  id: order_by
  issuanceToken: Token_order_by
  issuanceTokenDayData_aggregate: IssuanceTokenDayData_aggregate_order_by
  issuanceTokenHourData_aggregate: IssuanceTokenHourData_aggregate_order_by
  issuanceToken_id: order_by
  projectFees_aggregate: ProjectFee_aggregate_order_by
  protocolFees_aggregate: ProtocolFee_aggregate_order_by
  reserveCOL: order_by
  reserveUSD: order_by
  sellFee: order_by
  sellReserveRatio: order_by
  swaps_aggregate: Swap_aggregate_order_by
  virtualCOL: order_by
  virtualISS: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "BondingCurve"
"""
enum BondingCurve_select_column {
  """column name"""
  address

  """column name"""
  bcType

  """column name"""
  buyFee

  """column name"""
  buyReserveRatio

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  issuanceToken_id

  """column name"""
  reserveCOL

  """column name"""
  reserveUSD

  """column name"""
  sellFee

  """column name"""
  sellReserveRatio

  """column name"""
  virtualCOL

  """column name"""
  virtualISS

  """column name"""
  workflow_id
}

"""aggregate stddev on columns"""
type BondingCurve_stddev_fields {
  buyFee: Float
  buyReserveRatio: Float
  chainId: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
  sellReserveRatio: Float
  virtualCOL: Float
  virtualISS: Float
}

"""aggregate stddev_pop on columns"""
type BondingCurve_stddev_pop_fields {
  buyFee: Float
  buyReserveRatio: Float
  chainId: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
  sellReserveRatio: Float
  virtualCOL: Float
  virtualISS: Float
}

"""aggregate stddev_samp on columns"""
type BondingCurve_stddev_samp_fields {
  buyFee: Float
  buyReserveRatio: Float
  chainId: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
  sellReserveRatio: Float
  virtualCOL: Float
  virtualISS: Float
}

"""
Streaming cursor of the table "BondingCurve"
"""
input BondingCurve_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BondingCurve_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BondingCurve_stream_cursor_value_input {
  address: String
  bcType: String
  buyFee: numeric
  buyReserveRatio: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  id: String
  issuanceToken_id: String
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  sellReserveRatio: numeric
  virtualCOL: numeric
  virtualISS: numeric
  workflow_id: String
}

"""aggregate sum on columns"""
type BondingCurve_sum_fields {
  buyFee: numeric
  buyReserveRatio: numeric
  chainId: Int
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  sellReserveRatio: numeric
  virtualCOL: numeric
  virtualISS: numeric
}

"""aggregate var_pop on columns"""
type BondingCurve_var_pop_fields {
  buyFee: Float
  buyReserveRatio: Float
  chainId: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
  sellReserveRatio: Float
  virtualCOL: Float
  virtualISS: Float
}

"""aggregate var_samp on columns"""
type BondingCurve_var_samp_fields {
  buyFee: Float
  buyReserveRatio: Float
  chainId: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
  sellReserveRatio: Float
  virtualCOL: Float
  virtualISS: Float
}

"""aggregate variance on columns"""
type BondingCurve_variance_fields {
  buyFee: Float
  buyReserveRatio: Float
  chainId: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
  sellReserveRatio: Float
  virtualCOL: Float
  virtualISS: Float
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "Bounty"
"""
type Bounty {
  """An object relationship"""
  bountyModule: BountyModule
  bountyModule_id: String!

  """An array relationship"""
  claims(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!

  """An aggregate relationship"""
  claims_aggregate(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): BountyClaim_aggregate!
  db_write_timestamp: timestamp
  details: String!
  id: String!
  locked: Boolean
  maximumPayoutAmount: numeric!
  maximumPayoutAmountUSD: numeric!
  minimumPayoutAmount: numeric!
  minimumPayoutAmountUSD: numeric!
}

"""
columns and relationships of "BountyClaim"
"""
type BountyClaim {
  """An object relationship"""
  bounty: Bounty
  bounty_id: String!
  claimed: Boolean

  """An array relationship"""
  contributors(
    """distinct select on columns"""
    distinct_on: [BountyContributor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyContributor_order_by!]

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!
  db_write_timestamp: timestamp
  details: String!
  id: String!
}

"""
aggregated selection of "BountyClaim"
"""
type BountyClaim_aggregate {
  aggregate: BountyClaim_aggregate_fields
  nodes: [BountyClaim!]!
}

input BountyClaim_aggregate_bool_exp {
  bool_and: BountyClaim_aggregate_bool_exp_bool_and
  bool_or: BountyClaim_aggregate_bool_exp_bool_or
  count: BountyClaim_aggregate_bool_exp_count
}

input BountyClaim_aggregate_bool_exp_bool_and {
  arguments: BountyClaim_select_column_BountyClaim_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: BountyClaim_bool_exp
  predicate: Boolean_comparison_exp!
}

input BountyClaim_aggregate_bool_exp_bool_or {
  arguments: BountyClaim_select_column_BountyClaim_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: BountyClaim_bool_exp
  predicate: Boolean_comparison_exp!
}

input BountyClaim_aggregate_bool_exp_count {
  arguments: [BountyClaim_select_column!]
  distinct: Boolean
  filter: BountyClaim_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "BountyClaim"
"""
type BountyClaim_aggregate_fields {
  count(columns: [BountyClaim_select_column!], distinct: Boolean): Int!
  max: BountyClaim_max_fields
  min: BountyClaim_min_fields
}

"""
order by aggregate values of table "BountyClaim"
"""
input BountyClaim_aggregate_order_by {
  count: order_by
  max: BountyClaim_max_order_by
  min: BountyClaim_min_order_by
}

"""
Boolean expression to filter rows from the table "BountyClaim". All fields are combined with a logical 'AND'.
"""
input BountyClaim_bool_exp {
  _and: [BountyClaim_bool_exp!]
  _not: BountyClaim_bool_exp
  _or: [BountyClaim_bool_exp!]
  bounty: Bounty_bool_exp
  bounty_id: String_comparison_exp
  claimed: Boolean_comparison_exp
  contributors: BountyContributor_bool_exp
  db_write_timestamp: timestamp_comparison_exp
  details: String_comparison_exp
  id: String_comparison_exp
}

"""aggregate max on columns"""
type BountyClaim_max_fields {
  bounty_id: String
  db_write_timestamp: timestamp
  details: String
  id: String
}

"""
order by max() on columns of table "BountyClaim"
"""
input BountyClaim_max_order_by {
  bounty_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
}

"""aggregate min on columns"""
type BountyClaim_min_fields {
  bounty_id: String
  db_write_timestamp: timestamp
  details: String
  id: String
}

"""
order by min() on columns of table "BountyClaim"
"""
input BountyClaim_min_order_by {
  bounty_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
}

"""Ordering options when selecting data from "BountyClaim"."""
input BountyClaim_order_by {
  bounty: Bounty_order_by
  bounty_id: order_by
  claimed: order_by
  contributors_aggregate: BountyContributor_aggregate_order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
}

"""
select columns of table "BountyClaim"
"""
enum BountyClaim_select_column {
  """column name"""
  bounty_id

  """column name"""
  claimed

  """column name"""
  db_write_timestamp

  """column name"""
  details

  """column name"""
  id
}

"""
select "BountyClaim_aggregate_bool_exp_bool_and_arguments_columns" columns of table "BountyClaim"
"""
enum BountyClaim_select_column_BountyClaim_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  claimed
}

"""
select "BountyClaim_aggregate_bool_exp_bool_or_arguments_columns" columns of table "BountyClaim"
"""
enum BountyClaim_select_column_BountyClaim_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  claimed
}

"""
Streaming cursor of the table "BountyClaim"
"""
input BountyClaim_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BountyClaim_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BountyClaim_stream_cursor_value_input {
  bounty_id: String
  claimed: Boolean
  db_write_timestamp: timestamp
  details: String
  id: String
}

"""
columns and relationships of "BountyContributor"
"""
type BountyContributor {
  address: String!

  """An object relationship"""
  bountyClaim: BountyClaim
  bountyClaim_id: String!
  claimAmount: numeric!
  claimAmountUSD: numeric!
  db_write_timestamp: timestamp
  id: String!
}

"""
order by aggregate values of table "BountyContributor"
"""
input BountyContributor_aggregate_order_by {
  avg: BountyContributor_avg_order_by
  count: order_by
  max: BountyContributor_max_order_by
  min: BountyContributor_min_order_by
  stddev: BountyContributor_stddev_order_by
  stddev_pop: BountyContributor_stddev_pop_order_by
  stddev_samp: BountyContributor_stddev_samp_order_by
  sum: BountyContributor_sum_order_by
  var_pop: BountyContributor_var_pop_order_by
  var_samp: BountyContributor_var_samp_order_by
  variance: BountyContributor_variance_order_by
}

"""
order by avg() on columns of table "BountyContributor"
"""
input BountyContributor_avg_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
Boolean expression to filter rows from the table "BountyContributor". All fields are combined with a logical 'AND'.
"""
input BountyContributor_bool_exp {
  _and: [BountyContributor_bool_exp!]
  _not: BountyContributor_bool_exp
  _or: [BountyContributor_bool_exp!]
  address: String_comparison_exp
  bountyClaim: BountyClaim_bool_exp
  bountyClaim_id: String_comparison_exp
  claimAmount: numeric_comparison_exp
  claimAmountUSD: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
}

"""
order by max() on columns of table "BountyContributor"
"""
input BountyContributor_max_order_by {
  address: order_by
  bountyClaim_id: order_by
  claimAmount: order_by
  claimAmountUSD: order_by
  db_write_timestamp: order_by
  id: order_by
}

"""
order by min() on columns of table "BountyContributor"
"""
input BountyContributor_min_order_by {
  address: order_by
  bountyClaim_id: order_by
  claimAmount: order_by
  claimAmountUSD: order_by
  db_write_timestamp: order_by
  id: order_by
}

"""Ordering options when selecting data from "BountyContributor"."""
input BountyContributor_order_by {
  address: order_by
  bountyClaim: BountyClaim_order_by
  bountyClaim_id: order_by
  claimAmount: order_by
  claimAmountUSD: order_by
  db_write_timestamp: order_by
  id: order_by
}

"""
select columns of table "BountyContributor"
"""
enum BountyContributor_select_column {
  """column name"""
  address

  """column name"""
  bountyClaim_id

  """column name"""
  claimAmount

  """column name"""
  claimAmountUSD

  """column name"""
  db_write_timestamp

  """column name"""
  id
}

"""
order by stddev() on columns of table "BountyContributor"
"""
input BountyContributor_stddev_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
order by stddev_pop() on columns of table "BountyContributor"
"""
input BountyContributor_stddev_pop_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
order by stddev_samp() on columns of table "BountyContributor"
"""
input BountyContributor_stddev_samp_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
Streaming cursor of the table "BountyContributor"
"""
input BountyContributor_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BountyContributor_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BountyContributor_stream_cursor_value_input {
  address: String
  bountyClaim_id: String
  claimAmount: numeric
  claimAmountUSD: numeric
  db_write_timestamp: timestamp
  id: String
}

"""
order by sum() on columns of table "BountyContributor"
"""
input BountyContributor_sum_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
order by var_pop() on columns of table "BountyContributor"
"""
input BountyContributor_var_pop_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
order by var_samp() on columns of table "BountyContributor"
"""
input BountyContributor_var_samp_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
order by variance() on columns of table "BountyContributor"
"""
input BountyContributor_variance_order_by {
  claimAmount: order_by
  claimAmountUSD: order_by
}

"""
columns and relationships of "BountyModule"
"""
type BountyModule {
  address: String!

  """An array relationship"""
  bounties(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!

  """An aggregate relationship"""
  bounties_aggregate(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): Bounty_aggregate!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An object relationship"""
  token: Token
  token_id: String!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "BountyModule". All fields are combined with a logical 'AND'.
"""
input BountyModule_bool_exp {
  _and: [BountyModule_bool_exp!]
  _not: BountyModule_bool_exp
  _or: [BountyModule_bool_exp!]
  address: String_comparison_exp
  bounties: Bounty_bool_exp
  bounties_aggregate: Bounty_aggregate_bool_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "BountyModule"."""
input BountyModule_order_by {
  address: order_by
  bounties_aggregate: Bounty_aggregate_order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  token: Token_order_by
  token_id: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "BountyModule"
"""
enum BountyModule_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  token_id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "BountyModule"
"""
input BountyModule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: BountyModule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input BountyModule_stream_cursor_value_input {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  token_id: String
  workflow_id: String
}

"""
aggregated selection of "Bounty"
"""
type Bounty_aggregate {
  aggregate: Bounty_aggregate_fields
  nodes: [Bounty!]!
}

input Bounty_aggregate_bool_exp {
  bool_and: Bounty_aggregate_bool_exp_bool_and
  bool_or: Bounty_aggregate_bool_exp_bool_or
  count: Bounty_aggregate_bool_exp_count
}

input Bounty_aggregate_bool_exp_bool_and {
  arguments: Bounty_select_column_Bounty_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: Bounty_bool_exp
  predicate: Boolean_comparison_exp!
}

input Bounty_aggregate_bool_exp_bool_or {
  arguments: Bounty_select_column_Bounty_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: Bounty_bool_exp
  predicate: Boolean_comparison_exp!
}

input Bounty_aggregate_bool_exp_count {
  arguments: [Bounty_select_column!]
  distinct: Boolean
  filter: Bounty_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "Bounty"
"""
type Bounty_aggregate_fields {
  avg: Bounty_avg_fields
  count(columns: [Bounty_select_column!], distinct: Boolean): Int!
  max: Bounty_max_fields
  min: Bounty_min_fields
  stddev: Bounty_stddev_fields
  stddev_pop: Bounty_stddev_pop_fields
  stddev_samp: Bounty_stddev_samp_fields
  sum: Bounty_sum_fields
  var_pop: Bounty_var_pop_fields
  var_samp: Bounty_var_samp_fields
  variance: Bounty_variance_fields
}

"""
order by aggregate values of table "Bounty"
"""
input Bounty_aggregate_order_by {
  avg: Bounty_avg_order_by
  count: order_by
  max: Bounty_max_order_by
  min: Bounty_min_order_by
  stddev: Bounty_stddev_order_by
  stddev_pop: Bounty_stddev_pop_order_by
  stddev_samp: Bounty_stddev_samp_order_by
  sum: Bounty_sum_order_by
  var_pop: Bounty_var_pop_order_by
  var_samp: Bounty_var_samp_order_by
  variance: Bounty_variance_order_by
}

"""aggregate avg on columns"""
type Bounty_avg_fields {
  maximumPayoutAmount: Float
  maximumPayoutAmountUSD: Float
  minimumPayoutAmount: Float
  minimumPayoutAmountUSD: Float
}

"""
order by avg() on columns of table "Bounty"
"""
input Bounty_avg_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""
Boolean expression to filter rows from the table "Bounty". All fields are combined with a logical 'AND'.
"""
input Bounty_bool_exp {
  _and: [Bounty_bool_exp!]
  _not: Bounty_bool_exp
  _or: [Bounty_bool_exp!]
  bountyModule: BountyModule_bool_exp
  bountyModule_id: String_comparison_exp
  claims: BountyClaim_bool_exp
  claims_aggregate: BountyClaim_aggregate_bool_exp
  db_write_timestamp: timestamp_comparison_exp
  details: String_comparison_exp
  id: String_comparison_exp
  locked: Boolean_comparison_exp
  maximumPayoutAmount: numeric_comparison_exp
  maximumPayoutAmountUSD: numeric_comparison_exp
  minimumPayoutAmount: numeric_comparison_exp
  minimumPayoutAmountUSD: numeric_comparison_exp
}

"""aggregate max on columns"""
type Bounty_max_fields {
  bountyModule_id: String
  db_write_timestamp: timestamp
  details: String
  id: String
  maximumPayoutAmount: numeric
  maximumPayoutAmountUSD: numeric
  minimumPayoutAmount: numeric
  minimumPayoutAmountUSD: numeric
}

"""
order by max() on columns of table "Bounty"
"""
input Bounty_max_order_by {
  bountyModule_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""aggregate min on columns"""
type Bounty_min_fields {
  bountyModule_id: String
  db_write_timestamp: timestamp
  details: String
  id: String
  maximumPayoutAmount: numeric
  maximumPayoutAmountUSD: numeric
  minimumPayoutAmount: numeric
  minimumPayoutAmountUSD: numeric
}

"""
order by min() on columns of table "Bounty"
"""
input Bounty_min_order_by {
  bountyModule_id: order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""Ordering options when selecting data from "Bounty"."""
input Bounty_order_by {
  bountyModule: BountyModule_order_by
  bountyModule_id: order_by
  claims_aggregate: BountyClaim_aggregate_order_by
  db_write_timestamp: order_by
  details: order_by
  id: order_by
  locked: order_by
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""
select columns of table "Bounty"
"""
enum Bounty_select_column {
  """column name"""
  bountyModule_id

  """column name"""
  db_write_timestamp

  """column name"""
  details

  """column name"""
  id

  """column name"""
  locked

  """column name"""
  maximumPayoutAmount

  """column name"""
  maximumPayoutAmountUSD

  """column name"""
  minimumPayoutAmount

  """column name"""
  minimumPayoutAmountUSD
}

"""
select "Bounty_aggregate_bool_exp_bool_and_arguments_columns" columns of table "Bounty"
"""
enum Bounty_select_column_Bounty_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  locked
}

"""
select "Bounty_aggregate_bool_exp_bool_or_arguments_columns" columns of table "Bounty"
"""
enum Bounty_select_column_Bounty_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  locked
}

"""aggregate stddev on columns"""
type Bounty_stddev_fields {
  maximumPayoutAmount: Float
  maximumPayoutAmountUSD: Float
  minimumPayoutAmount: Float
  minimumPayoutAmountUSD: Float
}

"""
order by stddev() on columns of table "Bounty"
"""
input Bounty_stddev_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""aggregate stddev_pop on columns"""
type Bounty_stddev_pop_fields {
  maximumPayoutAmount: Float
  maximumPayoutAmountUSD: Float
  minimumPayoutAmount: Float
  minimumPayoutAmountUSD: Float
}

"""
order by stddev_pop() on columns of table "Bounty"
"""
input Bounty_stddev_pop_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""aggregate stddev_samp on columns"""
type Bounty_stddev_samp_fields {
  maximumPayoutAmount: Float
  maximumPayoutAmountUSD: Float
  minimumPayoutAmount: Float
  minimumPayoutAmountUSD: Float
}

"""
order by stddev_samp() on columns of table "Bounty"
"""
input Bounty_stddev_samp_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""
Streaming cursor of the table "Bounty"
"""
input Bounty_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Bounty_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Bounty_stream_cursor_value_input {
  bountyModule_id: String
  db_write_timestamp: timestamp
  details: String
  id: String
  locked: Boolean
  maximumPayoutAmount: numeric
  maximumPayoutAmountUSD: numeric
  minimumPayoutAmount: numeric
  minimumPayoutAmountUSD: numeric
}

"""aggregate sum on columns"""
type Bounty_sum_fields {
  maximumPayoutAmount: numeric
  maximumPayoutAmountUSD: numeric
  minimumPayoutAmount: numeric
  minimumPayoutAmountUSD: numeric
}

"""
order by sum() on columns of table "Bounty"
"""
input Bounty_sum_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""aggregate var_pop on columns"""
type Bounty_var_pop_fields {
  maximumPayoutAmount: Float
  maximumPayoutAmountUSD: Float
  minimumPayoutAmount: Float
  minimumPayoutAmountUSD: Float
}

"""
order by var_pop() on columns of table "Bounty"
"""
input Bounty_var_pop_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""aggregate var_samp on columns"""
type Bounty_var_samp_fields {
  maximumPayoutAmount: Float
  maximumPayoutAmountUSD: Float
  minimumPayoutAmount: Float
  minimumPayoutAmountUSD: Float
}

"""
order by var_samp() on columns of table "Bounty"
"""
input Bounty_var_samp_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""aggregate variance on columns"""
type Bounty_variance_fields {
  maximumPayoutAmount: Float
  maximumPayoutAmountUSD: Float
  minimumPayoutAmount: Float
  minimumPayoutAmountUSD: Float
}

"""
order by variance() on columns of table "Bounty"
"""
input Bounty_variance_order_by {
  maximumPayoutAmount: order_by
  maximumPayoutAmountUSD: order_by
  minimumPayoutAmount: order_by
  minimumPayoutAmountUSD: order_by
}

"""
columns and relationships of "CurveDayData"
"""
type CurveDayData {
  address: String!
  chainId: Int!
  closeCOL: numeric!
  closeUSD: numeric!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  date: Int!
  db_write_timestamp: timestamp
  fundingManager_id: String!
  highCOL: numeric!
  highUSD: numeric!
  id: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!
  lowCOL: numeric!
  lowUSD: numeric!
  openCOL: numeric!
  openUSD: numeric!
  priceCOL: numeric!
  priceUSD: numeric!
  projectFeeCOL: numeric!
  projectFeeUSD: numeric!
  protocolFeeCOL: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!
  volumeCOL: numeric!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
aggregated selection of "CurveDayData"
"""
type CurveDayData_aggregate {
  aggregate: CurveDayData_aggregate_fields
  nodes: [CurveDayData!]!
}

input CurveDayData_aggregate_bool_exp {
  count: CurveDayData_aggregate_bool_exp_count
}

input CurveDayData_aggregate_bool_exp_count {
  arguments: [CurveDayData_select_column!]
  distinct: Boolean
  filter: CurveDayData_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "CurveDayData"
"""
type CurveDayData_aggregate_fields {
  avg: CurveDayData_avg_fields
  count(columns: [CurveDayData_select_column!], distinct: Boolean): Int!
  max: CurveDayData_max_fields
  min: CurveDayData_min_fields
  stddev: CurveDayData_stddev_fields
  stddev_pop: CurveDayData_stddev_pop_fields
  stddev_samp: CurveDayData_stddev_samp_fields
  sum: CurveDayData_sum_fields
  var_pop: CurveDayData_var_pop_fields
  var_samp: CurveDayData_var_samp_fields
  variance: CurveDayData_variance_fields
}

"""
order by aggregate values of table "CurveDayData"
"""
input CurveDayData_aggregate_order_by {
  avg: CurveDayData_avg_order_by
  count: order_by
  max: CurveDayData_max_order_by
  min: CurveDayData_min_order_by
  stddev: CurveDayData_stddev_order_by
  stddev_pop: CurveDayData_stddev_pop_order_by
  stddev_samp: CurveDayData_stddev_samp_order_by
  sum: CurveDayData_sum_order_by
  var_pop: CurveDayData_var_pop_order_by
  var_samp: CurveDayData_var_samp_order_by
  variance: CurveDayData_variance_order_by
}

"""aggregate avg on columns"""
type CurveDayData_avg_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  date: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by avg() on columns of table "CurveDayData"
"""
input CurveDayData_avg_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "CurveDayData". All fields are combined with a logical 'AND'.
"""
input CurveDayData_bool_exp {
  _and: [CurveDayData_bool_exp!]
  _not: CurveDayData_bool_exp
  _or: [CurveDayData_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  closeCOL: numeric_comparison_exp
  closeUSD: numeric_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  date: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  fundingManager_id: String_comparison_exp
  highCOL: numeric_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  lowCOL: numeric_comparison_exp
  lowUSD: numeric_comparison_exp
  openCOL: numeric_comparison_exp
  openUSD: numeric_comparison_exp
  priceCOL: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeCOL: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeCOL: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  volumeCOL: numeric_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""aggregate max on columns"""
type CurveDayData_max_fields {
  address: String
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  date: Int
  db_write_timestamp: timestamp
  fundingManager_id: String
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by max() on columns of table "CurveDayData"
"""
input CurveDayData_max_order_by {
  address: order_by
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  date: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate min on columns"""
type CurveDayData_min_fields {
  address: String
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  date: Int
  db_write_timestamp: timestamp
  fundingManager_id: String
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by min() on columns of table "CurveDayData"
"""
input CurveDayData_min_order_by {
  address: order_by
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  date: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "CurveDayData"."""
input CurveDayData_order_by {
  address: order_by
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  date: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "CurveDayData"
"""
enum CurveDayData_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  closeCOL

  """column name"""
  closeUSD

  """column name"""
  collateralToken_id

  """column name"""
  date

  """column name"""
  db_write_timestamp

  """column name"""
  fundingManager_id

  """column name"""
  highCOL

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  issuanceToken_id

  """column name"""
  lowCOL

  """column name"""
  lowUSD

  """column name"""
  openCOL

  """column name"""
  openUSD

  """column name"""
  priceCOL

  """column name"""
  priceUSD

  """column name"""
  projectFeeCOL

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeCOL

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  volumeCOL

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""aggregate stddev on columns"""
type CurveDayData_stddev_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  date: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev() on columns of table "CurveDayData"
"""
input CurveDayData_stddev_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_pop on columns"""
type CurveDayData_stddev_pop_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  date: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_pop() on columns of table "CurveDayData"
"""
input CurveDayData_stddev_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_samp on columns"""
type CurveDayData_stddev_samp_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  date: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_samp() on columns of table "CurveDayData"
"""
input CurveDayData_stddev_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "CurveDayData"
"""
input CurveDayData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: CurveDayData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input CurveDayData_stream_cursor_value_input {
  address: String
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  date: Int
  db_write_timestamp: timestamp
  fundingManager_id: String
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""aggregate sum on columns"""
type CurveDayData_sum_fields {
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  date: Int
  highCOL: numeric
  highUSD: numeric
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "CurveDayData"
"""
input CurveDayData_sum_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_pop on columns"""
type CurveDayData_var_pop_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  date: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_pop() on columns of table "CurveDayData"
"""
input CurveDayData_var_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_samp on columns"""
type CurveDayData_var_samp_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  date: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_samp() on columns of table "CurveDayData"
"""
input CurveDayData_var_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate variance on columns"""
type CurveDayData_variance_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  date: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by variance() on columns of table "CurveDayData"
"""
input CurveDayData_variance_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  date: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "CurveHourData"
"""
type CurveHourData {
  address: String!
  chainId: Int!
  closeCOL: numeric!
  closeUSD: numeric!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  db_write_timestamp: timestamp
  fundingManager_id: String!
  highCOL: numeric!
  highUSD: numeric!
  id: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!
  lowCOL: numeric!
  lowUSD: numeric!
  openCOL: numeric!
  openUSD: numeric!
  periodStartUnix: Int!
  priceCOL: numeric!
  priceUSD: numeric!
  projectFeeCOL: numeric!
  projectFeeUSD: numeric!
  protocolFeeCOL: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!
  volumeCOL: numeric!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
aggregated selection of "CurveHourData"
"""
type CurveHourData_aggregate {
  aggregate: CurveHourData_aggregate_fields
  nodes: [CurveHourData!]!
}

input CurveHourData_aggregate_bool_exp {
  count: CurveHourData_aggregate_bool_exp_count
}

input CurveHourData_aggregate_bool_exp_count {
  arguments: [CurveHourData_select_column!]
  distinct: Boolean
  filter: CurveHourData_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "CurveHourData"
"""
type CurveHourData_aggregate_fields {
  avg: CurveHourData_avg_fields
  count(columns: [CurveHourData_select_column!], distinct: Boolean): Int!
  max: CurveHourData_max_fields
  min: CurveHourData_min_fields
  stddev: CurveHourData_stddev_fields
  stddev_pop: CurveHourData_stddev_pop_fields
  stddev_samp: CurveHourData_stddev_samp_fields
  sum: CurveHourData_sum_fields
  var_pop: CurveHourData_var_pop_fields
  var_samp: CurveHourData_var_samp_fields
  variance: CurveHourData_variance_fields
}

"""
order by aggregate values of table "CurveHourData"
"""
input CurveHourData_aggregate_order_by {
  avg: CurveHourData_avg_order_by
  count: order_by
  max: CurveHourData_max_order_by
  min: CurveHourData_min_order_by
  stddev: CurveHourData_stddev_order_by
  stddev_pop: CurveHourData_stddev_pop_order_by
  stddev_samp: CurveHourData_stddev_samp_order_by
  sum: CurveHourData_sum_order_by
  var_pop: CurveHourData_var_pop_order_by
  var_samp: CurveHourData_var_samp_order_by
  variance: CurveHourData_variance_order_by
}

"""aggregate avg on columns"""
type CurveHourData_avg_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  periodStartUnix: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by avg() on columns of table "CurveHourData"
"""
input CurveHourData_avg_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "CurveHourData". All fields are combined with a logical 'AND'.
"""
input CurveHourData_bool_exp {
  _and: [CurveHourData_bool_exp!]
  _not: CurveHourData_bool_exp
  _or: [CurveHourData_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  closeCOL: numeric_comparison_exp
  closeUSD: numeric_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  fundingManager_id: String_comparison_exp
  highCOL: numeric_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  lowCOL: numeric_comparison_exp
  lowUSD: numeric_comparison_exp
  openCOL: numeric_comparison_exp
  openUSD: numeric_comparison_exp
  periodStartUnix: Int_comparison_exp
  priceCOL: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeCOL: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeCOL: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  volumeCOL: numeric_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""aggregate max on columns"""
type CurveHourData_max_fields {
  address: String
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  db_write_timestamp: timestamp
  fundingManager_id: String
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  periodStartUnix: Int
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by max() on columns of table "CurveHourData"
"""
input CurveHourData_max_order_by {
  address: order_by
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate min on columns"""
type CurveHourData_min_fields {
  address: String
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  db_write_timestamp: timestamp
  fundingManager_id: String
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  periodStartUnix: Int
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by min() on columns of table "CurveHourData"
"""
input CurveHourData_min_order_by {
  address: order_by
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "CurveHourData"."""
input CurveHourData_order_by {
  address: order_by
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  highCOL: order_by
  highUSD: order_by
  id: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "CurveHourData"
"""
enum CurveHourData_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  closeCOL

  """column name"""
  closeUSD

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  fundingManager_id

  """column name"""
  highCOL

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  issuanceToken_id

  """column name"""
  lowCOL

  """column name"""
  lowUSD

  """column name"""
  openCOL

  """column name"""
  openUSD

  """column name"""
  periodStartUnix

  """column name"""
  priceCOL

  """column name"""
  priceUSD

  """column name"""
  projectFeeCOL

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeCOL

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  volumeCOL

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""aggregate stddev on columns"""
type CurveHourData_stddev_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  periodStartUnix: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev() on columns of table "CurveHourData"
"""
input CurveHourData_stddev_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_pop on columns"""
type CurveHourData_stddev_pop_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  periodStartUnix: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_pop() on columns of table "CurveHourData"
"""
input CurveHourData_stddev_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_samp on columns"""
type CurveHourData_stddev_samp_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  periodStartUnix: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_samp() on columns of table "CurveHourData"
"""
input CurveHourData_stddev_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "CurveHourData"
"""
input CurveHourData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: CurveHourData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input CurveHourData_stream_cursor_value_input {
  address: String
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  collateralToken_id: String
  db_write_timestamp: timestamp
  fundingManager_id: String
  highCOL: numeric
  highUSD: numeric
  id: String
  issuanceToken_id: String
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  periodStartUnix: Int
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""aggregate sum on columns"""
type CurveHourData_sum_fields {
  chainId: Int
  closeCOL: numeric
  closeUSD: numeric
  highCOL: numeric
  highUSD: numeric
  lowCOL: numeric
  lowUSD: numeric
  openCOL: numeric
  openUSD: numeric
  periodStartUnix: Int
  priceCOL: numeric
  priceUSD: numeric
  projectFeeCOL: numeric
  projectFeeUSD: numeric
  protocolFeeCOL: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeCOL: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "CurveHourData"
"""
input CurveHourData_sum_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_pop on columns"""
type CurveHourData_var_pop_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  periodStartUnix: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_pop() on columns of table "CurveHourData"
"""
input CurveHourData_var_pop_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_samp on columns"""
type CurveHourData_var_samp_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  periodStartUnix: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_samp() on columns of table "CurveHourData"
"""
input CurveHourData_var_samp_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate variance on columns"""
type CurveHourData_variance_fields {
  chainId: Float
  closeCOL: Float
  closeUSD: Float
  highCOL: Float
  highUSD: Float
  lowCOL: Float
  lowUSD: Float
  openCOL: Float
  openUSD: Float
  periodStartUnix: Float
  priceCOL: Float
  priceUSD: Float
  projectFeeCOL: Float
  projectFeeUSD: Float
  protocolFeeCOL: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeCOL: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by variance() on columns of table "CurveHourData"
"""
input CurveHourData_variance_order_by {
  chainId: order_by
  closeCOL: order_by
  closeUSD: order_by
  highCOL: order_by
  highUSD: order_by
  lowCOL: order_by
  lowUSD: order_by
  openCOL: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFeeCOL: order_by
  projectFeeUSD: order_by
  protocolFeeCOL: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeCOL: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "Deposit"
"""
type Deposit {
  amount: numeric!
  amountUSD: numeric!
  db_write_timestamp: timestamp

  """An object relationship"""
  depositVault: DepositVault
  depositVault_id: String!
  depositor: String!
  id: String!
  timestamp: Int!
  txHash: String!
}

"""
columns and relationships of "DepositVault"
"""
type DepositVault {
  address: String!
  balance: numeric!
  balanceUSD: numeric!
  chainId: Int!
  db_write_timestamp: timestamp

  """An array relationship"""
  deposits(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!

  """An aggregate relationship"""
  deposits_aggregate(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): Deposit_aggregate!
  id: String!

  """An object relationship"""
  token: Token
  token_id: String!

  """An array relationship"""
  transfers(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """An aggregate relationship"""
  transfers_aggregate(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): Transfer_aggregate!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
aggregated selection of "DepositVault"
"""
type DepositVault_aggregate {
  aggregate: DepositVault_aggregate_fields
  nodes: [DepositVault!]!
}

"""
aggregate fields of "DepositVault"
"""
type DepositVault_aggregate_fields {
  avg: DepositVault_avg_fields
  count(columns: [DepositVault_select_column!], distinct: Boolean): Int!
  max: DepositVault_max_fields
  min: DepositVault_min_fields
  stddev: DepositVault_stddev_fields
  stddev_pop: DepositVault_stddev_pop_fields
  stddev_samp: DepositVault_stddev_samp_fields
  sum: DepositVault_sum_fields
  var_pop: DepositVault_var_pop_fields
  var_samp: DepositVault_var_samp_fields
  variance: DepositVault_variance_fields
}

"""aggregate avg on columns"""
type DepositVault_avg_fields {
  balance: Float
  balanceUSD: Float
  chainId: Float
}

"""
Boolean expression to filter rows from the table "DepositVault". All fields are combined with a logical 'AND'.
"""
input DepositVault_bool_exp {
  _and: [DepositVault_bool_exp!]
  _not: DepositVault_bool_exp
  _or: [DepositVault_bool_exp!]
  address: String_comparison_exp
  balance: numeric_comparison_exp
  balanceUSD: numeric_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  deposits: Deposit_bool_exp
  deposits_aggregate: Deposit_aggregate_bool_exp
  id: String_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  transfers: Transfer_bool_exp
  transfers_aggregate: Transfer_aggregate_bool_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""aggregate max on columns"""
type DepositVault_max_fields {
  address: String
  balance: numeric
  balanceUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  token_id: String
  workflow_id: String
}

"""aggregate min on columns"""
type DepositVault_min_fields {
  address: String
  balance: numeric
  balanceUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  token_id: String
  workflow_id: String
}

"""Ordering options when selecting data from "DepositVault"."""
input DepositVault_order_by {
  address: order_by
  balance: order_by
  balanceUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  deposits_aggregate: Deposit_aggregate_order_by
  id: order_by
  token: Token_order_by
  token_id: order_by
  transfers_aggregate: Transfer_aggregate_order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "DepositVault"
"""
enum DepositVault_select_column {
  """column name"""
  address

  """column name"""
  balance

  """column name"""
  balanceUSD

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  token_id

  """column name"""
  workflow_id
}

"""aggregate stddev on columns"""
type DepositVault_stddev_fields {
  balance: Float
  balanceUSD: Float
  chainId: Float
}

"""aggregate stddev_pop on columns"""
type DepositVault_stddev_pop_fields {
  balance: Float
  balanceUSD: Float
  chainId: Float
}

"""aggregate stddev_samp on columns"""
type DepositVault_stddev_samp_fields {
  balance: Float
  balanceUSD: Float
  chainId: Float
}

"""
Streaming cursor of the table "DepositVault"
"""
input DepositVault_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: DepositVault_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input DepositVault_stream_cursor_value_input {
  address: String
  balance: numeric
  balanceUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  token_id: String
  workflow_id: String
}

"""aggregate sum on columns"""
type DepositVault_sum_fields {
  balance: numeric
  balanceUSD: numeric
  chainId: Int
}

"""aggregate var_pop on columns"""
type DepositVault_var_pop_fields {
  balance: Float
  balanceUSD: Float
  chainId: Float
}

"""aggregate var_samp on columns"""
type DepositVault_var_samp_fields {
  balance: Float
  balanceUSD: Float
  chainId: Float
}

"""aggregate variance on columns"""
type DepositVault_variance_fields {
  balance: Float
  balanceUSD: Float
  chainId: Float
}

"""
aggregated selection of "Deposit"
"""
type Deposit_aggregate {
  aggregate: Deposit_aggregate_fields
  nodes: [Deposit!]!
}

input Deposit_aggregate_bool_exp {
  count: Deposit_aggregate_bool_exp_count
}

input Deposit_aggregate_bool_exp_count {
  arguments: [Deposit_select_column!]
  distinct: Boolean
  filter: Deposit_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "Deposit"
"""
type Deposit_aggregate_fields {
  avg: Deposit_avg_fields
  count(columns: [Deposit_select_column!], distinct: Boolean): Int!
  max: Deposit_max_fields
  min: Deposit_min_fields
  stddev: Deposit_stddev_fields
  stddev_pop: Deposit_stddev_pop_fields
  stddev_samp: Deposit_stddev_samp_fields
  sum: Deposit_sum_fields
  var_pop: Deposit_var_pop_fields
  var_samp: Deposit_var_samp_fields
  variance: Deposit_variance_fields
}

"""
order by aggregate values of table "Deposit"
"""
input Deposit_aggregate_order_by {
  avg: Deposit_avg_order_by
  count: order_by
  max: Deposit_max_order_by
  min: Deposit_min_order_by
  stddev: Deposit_stddev_order_by
  stddev_pop: Deposit_stddev_pop_order_by
  stddev_samp: Deposit_stddev_samp_order_by
  sum: Deposit_sum_order_by
  var_pop: Deposit_var_pop_order_by
  var_samp: Deposit_var_samp_order_by
  variance: Deposit_variance_order_by
}

"""aggregate avg on columns"""
type Deposit_avg_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by avg() on columns of table "Deposit"
"""
input Deposit_avg_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "Deposit". All fields are combined with a logical 'AND'.
"""
input Deposit_bool_exp {
  _and: [Deposit_bool_exp!]
  _not: Deposit_bool_exp
  _or: [Deposit_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  depositVault: DepositVault_bool_exp
  depositVault_id: String_comparison_exp
  depositor: String_comparison_exp
  id: String_comparison_exp
  timestamp: Int_comparison_exp
  txHash: String_comparison_exp
}

"""aggregate max on columns"""
type Deposit_max_fields {
  amount: numeric
  amountUSD: numeric
  db_write_timestamp: timestamp
  depositVault_id: String
  depositor: String
  id: String
  timestamp: Int
  txHash: String
}

"""
order by max() on columns of table "Deposit"
"""
input Deposit_max_order_by {
  amount: order_by
  amountUSD: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  depositor: order_by
  id: order_by
  timestamp: order_by
  txHash: order_by
}

"""aggregate min on columns"""
type Deposit_min_fields {
  amount: numeric
  amountUSD: numeric
  db_write_timestamp: timestamp
  depositVault_id: String
  depositor: String
  id: String
  timestamp: Int
  txHash: String
}

"""
order by min() on columns of table "Deposit"
"""
input Deposit_min_order_by {
  amount: order_by
  amountUSD: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  depositor: order_by
  id: order_by
  timestamp: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "Deposit"."""
input Deposit_order_by {
  amount: order_by
  amountUSD: order_by
  db_write_timestamp: order_by
  depositVault: DepositVault_order_by
  depositVault_id: order_by
  depositor: order_by
  id: order_by
  timestamp: order_by
  txHash: order_by
}

"""
select columns of table "Deposit"
"""
enum Deposit_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  db_write_timestamp

  """column name"""
  depositVault_id

  """column name"""
  depositor

  """column name"""
  id

  """column name"""
  timestamp

  """column name"""
  txHash
}

"""aggregate stddev on columns"""
type Deposit_stddev_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by stddev() on columns of table "Deposit"
"""
input Deposit_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate stddev_pop on columns"""
type Deposit_stddev_pop_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by stddev_pop() on columns of table "Deposit"
"""
input Deposit_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate stddev_samp on columns"""
type Deposit_stddev_samp_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by stddev_samp() on columns of table "Deposit"
"""
input Deposit_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "Deposit"
"""
input Deposit_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Deposit_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Deposit_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  db_write_timestamp: timestamp
  depositVault_id: String
  depositor: String
  id: String
  timestamp: Int
  txHash: String
}

"""aggregate sum on columns"""
type Deposit_sum_fields {
  amount: numeric
  amountUSD: numeric
  timestamp: Int
}

"""
order by sum() on columns of table "Deposit"
"""
input Deposit_sum_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate var_pop on columns"""
type Deposit_var_pop_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by var_pop() on columns of table "Deposit"
"""
input Deposit_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate var_samp on columns"""
type Deposit_var_samp_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by var_samp() on columns of table "Deposit"
"""
input Deposit_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate variance on columns"""
type Deposit_variance_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by variance() on columns of table "Deposit"
"""
input Deposit_variance_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""
columns and relationships of "ExternalPrice"
"""
type ExternalPrice {
  chainId: Int!
  db_write_timestamp: timestamp
  executedBy: String!

  """An object relationship"""
  externalPriceSetter: ExternalPriceSetter
  externalPriceSetter_id: String!
  id: String!
  price: numeric!
  source: sourcetokentype!
  timestamp: Int!
  txHash: String!
}

"""
columns and relationships of "ExternalPriceSetter"
"""
type ExternalPriceSetter {
  address: String!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  db_write_timestamp: timestamp

  """An array relationship"""
  externalPrices(
    """distinct select on columns"""
    distinct_on: [ExternalPrice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ExternalPrice_order_by!]

    """filter the rows returned"""
    where: ExternalPrice_bool_exp
  ): [ExternalPrice!]!
  id: String!
  lastUpdated: Int!
  priceCOL: numeric!
  priceISS: numeric!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "ExternalPriceSetter". All fields are combined with a logical 'AND'.
"""
input ExternalPriceSetter_bool_exp {
  _and: [ExternalPriceSetter_bool_exp!]
  _not: ExternalPriceSetter_bool_exp
  _or: [ExternalPriceSetter_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  externalPrices: ExternalPrice_bool_exp
  id: String_comparison_exp
  lastUpdated: Int_comparison_exp
  priceCOL: numeric_comparison_exp
  priceISS: numeric_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "ExternalPriceSetter"."""
input ExternalPriceSetter_order_by {
  address: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  externalPrices_aggregate: ExternalPrice_aggregate_order_by
  id: order_by
  lastUpdated: order_by
  priceCOL: order_by
  priceISS: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "ExternalPriceSetter"
"""
enum ExternalPriceSetter_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lastUpdated

  """column name"""
  priceCOL

  """column name"""
  priceISS

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "ExternalPriceSetter"
"""
input ExternalPriceSetter_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ExternalPriceSetter_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ExternalPriceSetter_stream_cursor_value_input {
  address: String
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  id: String
  lastUpdated: Int
  priceCOL: numeric
  priceISS: numeric
  workflow_id: String
}

"""
order by aggregate values of table "ExternalPrice"
"""
input ExternalPrice_aggregate_order_by {
  avg: ExternalPrice_avg_order_by
  count: order_by
  max: ExternalPrice_max_order_by
  min: ExternalPrice_min_order_by
  stddev: ExternalPrice_stddev_order_by
  stddev_pop: ExternalPrice_stddev_pop_order_by
  stddev_samp: ExternalPrice_stddev_samp_order_by
  sum: ExternalPrice_sum_order_by
  var_pop: ExternalPrice_var_pop_order_by
  var_samp: ExternalPrice_var_samp_order_by
  variance: ExternalPrice_variance_order_by
}

"""
order by avg() on columns of table "ExternalPrice"
"""
input ExternalPrice_avg_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "ExternalPrice". All fields are combined with a logical 'AND'.
"""
input ExternalPrice_bool_exp {
  _and: [ExternalPrice_bool_exp!]
  _not: ExternalPrice_bool_exp
  _or: [ExternalPrice_bool_exp!]
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  executedBy: String_comparison_exp
  externalPriceSetter: ExternalPriceSetter_bool_exp
  externalPriceSetter_id: String_comparison_exp
  id: String_comparison_exp
  price: numeric_comparison_exp
  source: sourcetokentype_comparison_exp
  timestamp: Int_comparison_exp
  txHash: String_comparison_exp
}

"""
order by max() on columns of table "ExternalPrice"
"""
input ExternalPrice_max_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  executedBy: order_by
  externalPriceSetter_id: order_by
  id: order_by
  price: order_by
  source: order_by
  timestamp: order_by
  txHash: order_by
}

"""
order by min() on columns of table "ExternalPrice"
"""
input ExternalPrice_min_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  executedBy: order_by
  externalPriceSetter_id: order_by
  id: order_by
  price: order_by
  source: order_by
  timestamp: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "ExternalPrice"."""
input ExternalPrice_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  executedBy: order_by
  externalPriceSetter: ExternalPriceSetter_order_by
  externalPriceSetter_id: order_by
  id: order_by
  price: order_by
  source: order_by
  timestamp: order_by
  txHash: order_by
}

"""
select columns of table "ExternalPrice"
"""
enum ExternalPrice_select_column {
  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  executedBy

  """column name"""
  externalPriceSetter_id

  """column name"""
  id

  """column name"""
  price

  """column name"""
  source

  """column name"""
  timestamp

  """column name"""
  txHash
}

"""
order by stddev() on columns of table "ExternalPrice"
"""
input ExternalPrice_stddev_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "ExternalPrice"
"""
input ExternalPrice_stddev_pop_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "ExternalPrice"
"""
input ExternalPrice_stddev_samp_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "ExternalPrice"
"""
input ExternalPrice_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ExternalPrice_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ExternalPrice_stream_cursor_value_input {
  chainId: Int
  db_write_timestamp: timestamp
  executedBy: String
  externalPriceSetter_id: String
  id: String
  price: numeric
  source: sourcetokentype
  timestamp: Int
  txHash: String
}

"""
order by sum() on columns of table "ExternalPrice"
"""
input ExternalPrice_sum_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "ExternalPrice"
"""
input ExternalPrice_var_pop_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "ExternalPrice"
"""
input ExternalPrice_var_samp_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "ExternalPrice"
"""
input ExternalPrice_variance_order_by {
  chainId: order_by
  price: order_by
  timestamp: order_by
}

"""
columns and relationships of "Graduation"
"""
type Graduation {
  collateralTokenAmount: numeric!
  db_write_timestamp: timestamp
  id: String!
  issuanceTokenAmount: numeric!
  pool: String!
  timestamp: Int!
  txHash: String!
}

"""
Boolean expression to filter rows from the table "Graduation". All fields are combined with a logical 'AND'.
"""
input Graduation_bool_exp {
  _and: [Graduation_bool_exp!]
  _not: Graduation_bool_exp
  _or: [Graduation_bool_exp!]
  collateralTokenAmount: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  issuanceTokenAmount: numeric_comparison_exp
  pool: String_comparison_exp
  timestamp: Int_comparison_exp
  txHash: String_comparison_exp
}

"""Ordering options when selecting data from "Graduation"."""
input Graduation_order_by {
  collateralTokenAmount: order_by
  db_write_timestamp: order_by
  id: order_by
  issuanceTokenAmount: order_by
  pool: order_by
  timestamp: order_by
  txHash: order_by
}

"""
select columns of table "Graduation"
"""
enum Graduation_select_column {
  """column name"""
  collateralTokenAmount

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  issuanceTokenAmount

  """column name"""
  pool

  """column name"""
  timestamp

  """column name"""
  txHash
}

"""
Streaming cursor of the table "Graduation"
"""
input Graduation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Graduation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Graduation_stream_cursor_value_input {
  collateralTokenAmount: numeric
  db_write_timestamp: timestamp
  id: String
  issuanceTokenAmount: numeric
  pool: String
  timestamp: Int
  txHash: String
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "IssuanceTokenDayData"
"""
type IssuanceTokenDayData {
  address: String!
  chainId: Int!
  closeUSD: numeric!
  date: Int!
  db_write_timestamp: timestamp
  highUSD: numeric!
  id: String!
  lowUSD: numeric!
  module_id: String!
  openUSD: numeric!
  priceUSD: numeric!
  projectFeeUSD: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!

  """An object relationship"""
  token: Token
  token_id: String!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
aggregated selection of "IssuanceTokenDayData"
"""
type IssuanceTokenDayData_aggregate {
  aggregate: IssuanceTokenDayData_aggregate_fields
  nodes: [IssuanceTokenDayData!]!
}

input IssuanceTokenDayData_aggregate_bool_exp {
  count: IssuanceTokenDayData_aggregate_bool_exp_count
}

input IssuanceTokenDayData_aggregate_bool_exp_count {
  arguments: [IssuanceTokenDayData_select_column!]
  distinct: Boolean
  filter: IssuanceTokenDayData_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "IssuanceTokenDayData"
"""
type IssuanceTokenDayData_aggregate_fields {
  avg: IssuanceTokenDayData_avg_fields
  count(columns: [IssuanceTokenDayData_select_column!], distinct: Boolean): Int!
  max: IssuanceTokenDayData_max_fields
  min: IssuanceTokenDayData_min_fields
  stddev: IssuanceTokenDayData_stddev_fields
  stddev_pop: IssuanceTokenDayData_stddev_pop_fields
  stddev_samp: IssuanceTokenDayData_stddev_samp_fields
  sum: IssuanceTokenDayData_sum_fields
  var_pop: IssuanceTokenDayData_var_pop_fields
  var_samp: IssuanceTokenDayData_var_samp_fields
  variance: IssuanceTokenDayData_variance_fields
}

"""
order by aggregate values of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_aggregate_order_by {
  avg: IssuanceTokenDayData_avg_order_by
  count: order_by
  max: IssuanceTokenDayData_max_order_by
  min: IssuanceTokenDayData_min_order_by
  stddev: IssuanceTokenDayData_stddev_order_by
  stddev_pop: IssuanceTokenDayData_stddev_pop_order_by
  stddev_samp: IssuanceTokenDayData_stddev_samp_order_by
  sum: IssuanceTokenDayData_sum_order_by
  var_pop: IssuanceTokenDayData_var_pop_order_by
  var_samp: IssuanceTokenDayData_var_samp_order_by
  variance: IssuanceTokenDayData_variance_order_by
}

"""aggregate avg on columns"""
type IssuanceTokenDayData_avg_fields {
  chainId: Float
  closeUSD: Float
  date: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by avg() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_avg_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "IssuanceTokenDayData". All fields are combined with a logical 'AND'.
"""
input IssuanceTokenDayData_bool_exp {
  _and: [IssuanceTokenDayData_bool_exp!]
  _not: IssuanceTokenDayData_bool_exp
  _or: [IssuanceTokenDayData_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  closeUSD: numeric_comparison_exp
  date: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  lowUSD: numeric_comparison_exp
  module_id: String_comparison_exp
  openUSD: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""aggregate max on columns"""
type IssuanceTokenDayData_max_fields {
  address: String
  chainId: Int
  closeUSD: numeric
  date: Int
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  module_id: String
  openUSD: numeric
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by max() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_max_order_by {
  address: order_by
  chainId: order_by
  closeUSD: order_by
  date: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  module_id: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate min on columns"""
type IssuanceTokenDayData_min_fields {
  address: String
  chainId: Int
  closeUSD: numeric
  date: Int
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  module_id: String
  openUSD: numeric
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by min() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_min_order_by {
  address: order_by
  chainId: order_by
  closeUSD: order_by
  date: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  module_id: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "IssuanceTokenDayData"."""
input IssuanceTokenDayData_order_by {
  address: order_by
  chainId: order_by
  closeUSD: order_by
  date: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  module_id: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token: Token_order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "IssuanceTokenDayData"
"""
enum IssuanceTokenDayData_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  closeUSD

  """column name"""
  date

  """column name"""
  db_write_timestamp

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  lowUSD

  """column name"""
  module_id

  """column name"""
  openUSD

  """column name"""
  priceUSD

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  token_id

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""aggregate stddev on columns"""
type IssuanceTokenDayData_stddev_fields {
  chainId: Float
  closeUSD: Float
  date: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stddev_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_pop on columns"""
type IssuanceTokenDayData_stddev_pop_fields {
  chainId: Float
  closeUSD: Float
  date: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_pop() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stddev_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_samp on columns"""
type IssuanceTokenDayData_stddev_samp_fields {
  chainId: Float
  closeUSD: Float
  date: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_samp() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stddev_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: IssuanceTokenDayData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input IssuanceTokenDayData_stream_cursor_value_input {
  address: String
  chainId: Int
  closeUSD: numeric
  date: Int
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  module_id: String
  openUSD: numeric
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""aggregate sum on columns"""
type IssuanceTokenDayData_sum_fields {
  chainId: Int
  closeUSD: numeric
  date: Int
  highUSD: numeric
  lowUSD: numeric
  openUSD: numeric
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_sum_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_pop on columns"""
type IssuanceTokenDayData_var_pop_fields {
  chainId: Float
  closeUSD: Float
  date: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_pop() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_var_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_samp on columns"""
type IssuanceTokenDayData_var_samp_fields {
  chainId: Float
  closeUSD: Float
  date: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_samp() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_var_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate variance on columns"""
type IssuanceTokenDayData_variance_fields {
  chainId: Float
  closeUSD: Float
  date: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by variance() on columns of table "IssuanceTokenDayData"
"""
input IssuanceTokenDayData_variance_order_by {
  chainId: order_by
  closeUSD: order_by
  date: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "IssuanceTokenHourData"
"""
type IssuanceTokenHourData {
  address: String!
  chainId: Int!
  closeUSD: numeric!
  db_write_timestamp: timestamp
  highUSD: numeric!
  id: String!
  lowUSD: numeric!
  module_id: String!
  openUSD: numeric!
  periodStartUnix: Int!
  priceUSD: numeric!
  projectFeeUSD: numeric!
  protocolFeeISS: numeric!
  protocolFeeUSD: numeric!

  """An object relationship"""
  token: Token
  token_id: String!
  volumeISS: numeric!
  volumeUSD: numeric!
}

"""
aggregated selection of "IssuanceTokenHourData"
"""
type IssuanceTokenHourData_aggregate {
  aggregate: IssuanceTokenHourData_aggregate_fields
  nodes: [IssuanceTokenHourData!]!
}

input IssuanceTokenHourData_aggregate_bool_exp {
  count: IssuanceTokenHourData_aggregate_bool_exp_count
}

input IssuanceTokenHourData_aggregate_bool_exp_count {
  arguments: [IssuanceTokenHourData_select_column!]
  distinct: Boolean
  filter: IssuanceTokenHourData_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "IssuanceTokenHourData"
"""
type IssuanceTokenHourData_aggregate_fields {
  avg: IssuanceTokenHourData_avg_fields
  count(columns: [IssuanceTokenHourData_select_column!], distinct: Boolean): Int!
  max: IssuanceTokenHourData_max_fields
  min: IssuanceTokenHourData_min_fields
  stddev: IssuanceTokenHourData_stddev_fields
  stddev_pop: IssuanceTokenHourData_stddev_pop_fields
  stddev_samp: IssuanceTokenHourData_stddev_samp_fields
  sum: IssuanceTokenHourData_sum_fields
  var_pop: IssuanceTokenHourData_var_pop_fields
  var_samp: IssuanceTokenHourData_var_samp_fields
  variance: IssuanceTokenHourData_variance_fields
}

"""
order by aggregate values of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_aggregate_order_by {
  avg: IssuanceTokenHourData_avg_order_by
  count: order_by
  max: IssuanceTokenHourData_max_order_by
  min: IssuanceTokenHourData_min_order_by
  stddev: IssuanceTokenHourData_stddev_order_by
  stddev_pop: IssuanceTokenHourData_stddev_pop_order_by
  stddev_samp: IssuanceTokenHourData_stddev_samp_order_by
  sum: IssuanceTokenHourData_sum_order_by
  var_pop: IssuanceTokenHourData_var_pop_order_by
  var_samp: IssuanceTokenHourData_var_samp_order_by
  variance: IssuanceTokenHourData_variance_order_by
}

"""aggregate avg on columns"""
type IssuanceTokenHourData_avg_fields {
  chainId: Float
  closeUSD: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  periodStartUnix: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by avg() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_avg_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Boolean expression to filter rows from the table "IssuanceTokenHourData". All fields are combined with a logical 'AND'.
"""
input IssuanceTokenHourData_bool_exp {
  _and: [IssuanceTokenHourData_bool_exp!]
  _not: IssuanceTokenHourData_bool_exp
  _or: [IssuanceTokenHourData_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  closeUSD: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  highUSD: numeric_comparison_exp
  id: String_comparison_exp
  lowUSD: numeric_comparison_exp
  module_id: String_comparison_exp
  openUSD: numeric_comparison_exp
  periodStartUnix: Int_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFeeUSD: numeric_comparison_exp
  protocolFeeISS: numeric_comparison_exp
  protocolFeeUSD: numeric_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  volumeISS: numeric_comparison_exp
  volumeUSD: numeric_comparison_exp
}

"""aggregate max on columns"""
type IssuanceTokenHourData_max_fields {
  address: String
  chainId: Int
  closeUSD: numeric
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  module_id: String
  openUSD: numeric
  periodStartUnix: Int
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by max() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_max_order_by {
  address: order_by
  chainId: order_by
  closeUSD: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  module_id: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate min on columns"""
type IssuanceTokenHourData_min_fields {
  address: String
  chainId: Int
  closeUSD: numeric
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  module_id: String
  openUSD: numeric
  periodStartUnix: Int
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by min() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_min_order_by {
  address: order_by
  chainId: order_by
  closeUSD: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  module_id: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""Ordering options when selecting data from "IssuanceTokenHourData"."""
input IssuanceTokenHourData_order_by {
  address: order_by
  chainId: order_by
  closeUSD: order_by
  db_write_timestamp: order_by
  highUSD: order_by
  id: order_by
  lowUSD: order_by
  module_id: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  token: Token_order_by
  token_id: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
select columns of table "IssuanceTokenHourData"
"""
enum IssuanceTokenHourData_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  closeUSD

  """column name"""
  db_write_timestamp

  """column name"""
  highUSD

  """column name"""
  id

  """column name"""
  lowUSD

  """column name"""
  module_id

  """column name"""
  openUSD

  """column name"""
  periodStartUnix

  """column name"""
  priceUSD

  """column name"""
  projectFeeUSD

  """column name"""
  protocolFeeISS

  """column name"""
  protocolFeeUSD

  """column name"""
  token_id

  """column name"""
  volumeISS

  """column name"""
  volumeUSD
}

"""aggregate stddev on columns"""
type IssuanceTokenHourData_stddev_fields {
  chainId: Float
  closeUSD: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  periodStartUnix: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stddev_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_pop on columns"""
type IssuanceTokenHourData_stddev_pop_fields {
  chainId: Float
  closeUSD: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  periodStartUnix: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_pop() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stddev_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate stddev_samp on columns"""
type IssuanceTokenHourData_stddev_samp_fields {
  chainId: Float
  closeUSD: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  periodStartUnix: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by stddev_samp() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stddev_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
Streaming cursor of the table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: IssuanceTokenHourData_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input IssuanceTokenHourData_stream_cursor_value_input {
  address: String
  chainId: Int
  closeUSD: numeric
  db_write_timestamp: timestamp
  highUSD: numeric
  id: String
  lowUSD: numeric
  module_id: String
  openUSD: numeric
  periodStartUnix: Int
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  token_id: String
  volumeISS: numeric
  volumeUSD: numeric
}

"""aggregate sum on columns"""
type IssuanceTokenHourData_sum_fields {
  chainId: Int
  closeUSD: numeric
  highUSD: numeric
  lowUSD: numeric
  openUSD: numeric
  periodStartUnix: Int
  priceUSD: numeric
  projectFeeUSD: numeric
  protocolFeeISS: numeric
  protocolFeeUSD: numeric
  volumeISS: numeric
  volumeUSD: numeric
}

"""
order by sum() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_sum_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_pop on columns"""
type IssuanceTokenHourData_var_pop_fields {
  chainId: Float
  closeUSD: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  periodStartUnix: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_pop() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_var_pop_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate var_samp on columns"""
type IssuanceTokenHourData_var_samp_fields {
  chainId: Float
  closeUSD: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  periodStartUnix: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by var_samp() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_var_samp_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""aggregate variance on columns"""
type IssuanceTokenHourData_variance_fields {
  chainId: Float
  closeUSD: Float
  highUSD: Float
  lowUSD: Float
  openUSD: Float
  periodStartUnix: Float
  priceUSD: Float
  projectFeeUSD: Float
  protocolFeeISS: Float
  protocolFeeUSD: Float
  volumeISS: Float
  volumeUSD: Float
}

"""
order by variance() on columns of table "IssuanceTokenHourData"
"""
input IssuanceTokenHourData_variance_order_by {
  chainId: order_by
  closeUSD: order_by
  highUSD: order_by
  lowUSD: order_by
  openUSD: order_by
  periodStartUnix: order_by
  priceUSD: order_by
  projectFeeUSD: order_by
  protocolFeeISS: order_by
  protocolFeeUSD: order_by
  volumeISS: order_by
  volumeUSD: order_by
}

"""
columns and relationships of "LinearVesting"
"""
type LinearVesting {
  amount: numeric!
  chainId: Int!
  cliff: numeric!
  db_write_timestamp: timestamp
  end: numeric!
  id: String!
  recipient: String!
  start: numeric!
  status: vestingstatus!

  """An object relationship"""
  streamingPaymentProcessor: StreamingPaymentProcessor
  streamingPaymentProcessor_id: String!
  timestamp: Int!

  """An object relationship"""
  token: Token
  token_id: String!
}

"""
order by aggregate values of table "LinearVesting"
"""
input LinearVesting_aggregate_order_by {
  avg: LinearVesting_avg_order_by
  count: order_by
  max: LinearVesting_max_order_by
  min: LinearVesting_min_order_by
  stddev: LinearVesting_stddev_order_by
  stddev_pop: LinearVesting_stddev_pop_order_by
  stddev_samp: LinearVesting_stddev_samp_order_by
  sum: LinearVesting_sum_order_by
  var_pop: LinearVesting_var_pop_order_by
  var_samp: LinearVesting_var_samp_order_by
  variance: LinearVesting_variance_order_by
}

"""
order by avg() on columns of table "LinearVesting"
"""
input LinearVesting_avg_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "LinearVesting". All fields are combined with a logical 'AND'.
"""
input LinearVesting_bool_exp {
  _and: [LinearVesting_bool_exp!]
  _not: LinearVesting_bool_exp
  _or: [LinearVesting_bool_exp!]
  amount: numeric_comparison_exp
  chainId: Int_comparison_exp
  cliff: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  end: numeric_comparison_exp
  id: String_comparison_exp
  recipient: String_comparison_exp
  start: numeric_comparison_exp
  status: vestingstatus_comparison_exp
  streamingPaymentProcessor: StreamingPaymentProcessor_bool_exp
  streamingPaymentProcessor_id: String_comparison_exp
  timestamp: Int_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
}

"""
order by max() on columns of table "LinearVesting"
"""
input LinearVesting_max_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor_id: order_by
  timestamp: order_by
  token_id: order_by
}

"""
order by min() on columns of table "LinearVesting"
"""
input LinearVesting_min_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor_id: order_by
  timestamp: order_by
  token_id: order_by
}

"""Ordering options when selecting data from "LinearVesting"."""
input LinearVesting_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  db_write_timestamp: order_by
  end: order_by
  id: order_by
  recipient: order_by
  start: order_by
  status: order_by
  streamingPaymentProcessor: StreamingPaymentProcessor_order_by
  streamingPaymentProcessor_id: order_by
  timestamp: order_by
  token: Token_order_by
  token_id: order_by
}

"""
select columns of table "LinearVesting"
"""
enum LinearVesting_select_column {
  """column name"""
  amount

  """column name"""
  chainId

  """column name"""
  cliff

  """column name"""
  db_write_timestamp

  """column name"""
  end

  """column name"""
  id

  """column name"""
  recipient

  """column name"""
  start

  """column name"""
  status

  """column name"""
  streamingPaymentProcessor_id

  """column name"""
  timestamp

  """column name"""
  token_id
}

"""
order by stddev() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_pop_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "LinearVesting"
"""
input LinearVesting_stddev_samp_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "LinearVesting"
"""
input LinearVesting_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: LinearVesting_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input LinearVesting_stream_cursor_value_input {
  amount: numeric
  chainId: Int
  cliff: numeric
  db_write_timestamp: timestamp
  end: numeric
  id: String
  recipient: String
  start: numeric
  status: vestingstatus
  streamingPaymentProcessor_id: String
  timestamp: Int
  token_id: String
}

"""
order by sum() on columns of table "LinearVesting"
"""
input LinearVesting_sum_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "LinearVesting"
"""
input LinearVesting_var_pop_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "LinearVesting"
"""
input LinearVesting_var_samp_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "LinearVesting"
"""
input LinearVesting_variance_order_by {
  amount: order_by
  chainId: order_by
  cliff: order_by
  end: order_by
  start: order_by
  timestamp: order_by
}

"""
columns and relationships of "MigratingPIM"
"""
type MigratingPIM {
  address: String!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  db_write_timestamp: timestamp
  deployer: String!

  """An object relationship"""
  graduation: Graduation
  graduation_id: String!
  id: String!
  initiator: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!

  """An object relationship"""
  migrationConfig: MigrationConfig
  migrationConfig_id: String!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "MigratingPIM". All fields are combined with a logical 'AND'.
"""
input MigratingPIM_bool_exp {
  _and: [MigratingPIM_bool_exp!]
  _not: MigratingPIM_bool_exp
  _or: [MigratingPIM_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  deployer: String_comparison_exp
  graduation: Graduation_bool_exp
  graduation_id: String_comparison_exp
  id: String_comparison_exp
  initiator: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  migrationConfig: MigrationConfig_bool_exp
  migrationConfig_id: String_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "MigratingPIM"."""
input MigratingPIM_order_by {
  address: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  deployer: order_by
  graduation: Graduation_order_by
  graduation_id: order_by
  id: order_by
  initiator: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  migrationConfig: MigrationConfig_order_by
  migrationConfig_id: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "MigratingPIM"
"""
enum MigratingPIM_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  deployer

  """column name"""
  graduation_id

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  issuanceToken_id

  """column name"""
  migrationConfig_id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "MigratingPIM"
"""
input MigratingPIM_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: MigratingPIM_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input MigratingPIM_stream_cursor_value_input {
  address: String
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  deployer: String
  graduation_id: String
  id: String
  initiator: String
  issuanceToken_id: String
  migrationConfig_id: String
  workflow_id: String
}

"""
columns and relationships of "MigrationConfig"
"""
type MigrationConfig {
  db_write_timestamp: timestamp
  dexAdapter: String!
  id: String!
  initialRewardDuration: numeric!
  isImmutable: Boolean!
  lpTokenRecipient: String!
  migrationThreshold: numeric!
}

"""
Boolean expression to filter rows from the table "MigrationConfig". All fields are combined with a logical 'AND'.
"""
input MigrationConfig_bool_exp {
  _and: [MigrationConfig_bool_exp!]
  _not: MigrationConfig_bool_exp
  _or: [MigrationConfig_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  dexAdapter: String_comparison_exp
  id: String_comparison_exp
  initialRewardDuration: numeric_comparison_exp
  isImmutable: Boolean_comparison_exp
  lpTokenRecipient: String_comparison_exp
  migrationThreshold: numeric_comparison_exp
}

"""Ordering options when selecting data from "MigrationConfig"."""
input MigrationConfig_order_by {
  db_write_timestamp: order_by
  dexAdapter: order_by
  id: order_by
  initialRewardDuration: order_by
  isImmutable: order_by
  lpTokenRecipient: order_by
  migrationThreshold: order_by
}

"""
select columns of table "MigrationConfig"
"""
enum MigrationConfig_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  dexAdapter

  """column name"""
  id

  """column name"""
  initialRewardDuration

  """column name"""
  isImmutable

  """column name"""
  lpTokenRecipient

  """column name"""
  migrationThreshold
}

"""
Streaming cursor of the table "MigrationConfig"
"""
input MigrationConfig_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: MigrationConfig_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input MigrationConfig_stream_cursor_value_input {
  db_write_timestamp: timestamp
  dexAdapter: String
  id: String
  initialRewardDuration: numeric
  isImmutable: Boolean
  lpTokenRecipient: String
  migrationThreshold: numeric
}

"""
columns and relationships of "OraclePriceFM"
"""
type OraclePriceFM {
  address: String!
  buyFee: numeric!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!

  """An array relationship"""
  curveDayData(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """An aggregate relationship"""
  curveDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): CurveDayData_aggregate!

  """An array relationship"""
  curveHourData(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """An aggregate relationship"""
  curveHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): CurveHourData_aggregate!
  db_write_timestamp: timestamp

  """An object relationship"""
  externalPriceSetter: ExternalPriceSetter
  externalPriceSetter_id: String
  id: String!

  """An object relationship"""
  issuanceToken: Token

  """An array relationship"""
  issuanceTokenDayData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """An aggregate relationship"""
  issuanceTokenDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): IssuanceTokenDayData_aggregate!

  """An array relationship"""
  issuanceTokenHourData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """An aggregate relationship"""
  issuanceTokenHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): IssuanceTokenHourData_aggregate!
  issuanceToken_id: String!
  maxBuyFee: numeric!
  maxSellFee: numeric!

  """An array relationship"""
  orders(
    """distinct select on columns"""
    distinct_on: [OraclePriceOrder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [OraclePriceOrder_order_by!]

    """filter the rows returned"""
    where: OraclePriceOrder_bool_exp
  ): [OraclePriceOrder!]!
  pendingRedemptionCOL: numeric!
  pendingRedemptionUSD: numeric!

  """An array relationship"""
  projectFees(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """An aggregate relationship"""
  projectFees_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): ProjectFee_aggregate!

  """An array relationship"""
  protocolFees(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """An aggregate relationship"""
  protocolFees_aggregate(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): ProtocolFee_aggregate!
  reserveCOL: numeric!
  reserveUSD: numeric!
  sellFee: numeric!
  treasury: String!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
aggregated selection of "OraclePriceFM"
"""
type OraclePriceFM_aggregate {
  aggregate: OraclePriceFM_aggregate_fields
  nodes: [OraclePriceFM!]!
}

"""
aggregate fields of "OraclePriceFM"
"""
type OraclePriceFM_aggregate_fields {
  avg: OraclePriceFM_avg_fields
  count(columns: [OraclePriceFM_select_column!], distinct: Boolean): Int!
  max: OraclePriceFM_max_fields
  min: OraclePriceFM_min_fields
  stddev: OraclePriceFM_stddev_fields
  stddev_pop: OraclePriceFM_stddev_pop_fields
  stddev_samp: OraclePriceFM_stddev_samp_fields
  sum: OraclePriceFM_sum_fields
  var_pop: OraclePriceFM_var_pop_fields
  var_samp: OraclePriceFM_var_samp_fields
  variance: OraclePriceFM_variance_fields
}

"""aggregate avg on columns"""
type OraclePriceFM_avg_fields {
  buyFee: Float
  chainId: Float
  maxBuyFee: Float
  maxSellFee: Float
  pendingRedemptionCOL: Float
  pendingRedemptionUSD: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
}

"""
Boolean expression to filter rows from the table "OraclePriceFM". All fields are combined with a logical 'AND'.
"""
input OraclePriceFM_bool_exp {
  _and: [OraclePriceFM_bool_exp!]
  _not: OraclePriceFM_bool_exp
  _or: [OraclePriceFM_bool_exp!]
  address: String_comparison_exp
  buyFee: numeric_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  curveDayData: CurveDayData_bool_exp
  curveDayData_aggregate: CurveDayData_aggregate_bool_exp
  curveHourData: CurveHourData_bool_exp
  curveHourData_aggregate: CurveHourData_aggregate_bool_exp
  db_write_timestamp: timestamp_comparison_exp
  externalPriceSetter: ExternalPriceSetter_bool_exp
  externalPriceSetter_id: String_comparison_exp
  id: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceTokenDayData: IssuanceTokenDayData_bool_exp
  issuanceTokenDayData_aggregate: IssuanceTokenDayData_aggregate_bool_exp
  issuanceTokenHourData: IssuanceTokenHourData_bool_exp
  issuanceTokenHourData_aggregate: IssuanceTokenHourData_aggregate_bool_exp
  issuanceToken_id: String_comparison_exp
  maxBuyFee: numeric_comparison_exp
  maxSellFee: numeric_comparison_exp
  orders: OraclePriceOrder_bool_exp
  pendingRedemptionCOL: numeric_comparison_exp
  pendingRedemptionUSD: numeric_comparison_exp
  projectFees: ProjectFee_bool_exp
  projectFees_aggregate: ProjectFee_aggregate_bool_exp
  protocolFees: ProtocolFee_bool_exp
  protocolFees_aggregate: ProtocolFee_aggregate_bool_exp
  reserveCOL: numeric_comparison_exp
  reserveUSD: numeric_comparison_exp
  sellFee: numeric_comparison_exp
  treasury: String_comparison_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""aggregate max on columns"""
type OraclePriceFM_max_fields {
  address: String
  buyFee: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  externalPriceSetter_id: String
  id: String
  issuanceToken_id: String
  maxBuyFee: numeric
  maxSellFee: numeric
  pendingRedemptionCOL: numeric
  pendingRedemptionUSD: numeric
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  treasury: String
  workflow_id: String
}

"""aggregate min on columns"""
type OraclePriceFM_min_fields {
  address: String
  buyFee: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  externalPriceSetter_id: String
  id: String
  issuanceToken_id: String
  maxBuyFee: numeric
  maxSellFee: numeric
  pendingRedemptionCOL: numeric
  pendingRedemptionUSD: numeric
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  treasury: String
  workflow_id: String
}

"""Ordering options when selecting data from "OraclePriceFM"."""
input OraclePriceFM_order_by {
  address: order_by
  buyFee: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  curveDayData_aggregate: CurveDayData_aggregate_order_by
  curveHourData_aggregate: CurveHourData_aggregate_order_by
  db_write_timestamp: order_by
  externalPriceSetter: ExternalPriceSetter_order_by
  externalPriceSetter_id: order_by
  id: order_by
  issuanceToken: Token_order_by
  issuanceTokenDayData_aggregate: IssuanceTokenDayData_aggregate_order_by
  issuanceTokenHourData_aggregate: IssuanceTokenHourData_aggregate_order_by
  issuanceToken_id: order_by
  maxBuyFee: order_by
  maxSellFee: order_by
  orders_aggregate: OraclePriceOrder_aggregate_order_by
  pendingRedemptionCOL: order_by
  pendingRedemptionUSD: order_by
  projectFees_aggregate: ProjectFee_aggregate_order_by
  protocolFees_aggregate: ProtocolFee_aggregate_order_by
  reserveCOL: order_by
  reserveUSD: order_by
  sellFee: order_by
  treasury: order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "OraclePriceFM"
"""
enum OraclePriceFM_select_column {
  """column name"""
  address

  """column name"""
  buyFee

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  externalPriceSetter_id

  """column name"""
  id

  """column name"""
  issuanceToken_id

  """column name"""
  maxBuyFee

  """column name"""
  maxSellFee

  """column name"""
  pendingRedemptionCOL

  """column name"""
  pendingRedemptionUSD

  """column name"""
  reserveCOL

  """column name"""
  reserveUSD

  """column name"""
  sellFee

  """column name"""
  treasury

  """column name"""
  workflow_id
}

"""aggregate stddev on columns"""
type OraclePriceFM_stddev_fields {
  buyFee: Float
  chainId: Float
  maxBuyFee: Float
  maxSellFee: Float
  pendingRedemptionCOL: Float
  pendingRedemptionUSD: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
}

"""aggregate stddev_pop on columns"""
type OraclePriceFM_stddev_pop_fields {
  buyFee: Float
  chainId: Float
  maxBuyFee: Float
  maxSellFee: Float
  pendingRedemptionCOL: Float
  pendingRedemptionUSD: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
}

"""aggregate stddev_samp on columns"""
type OraclePriceFM_stddev_samp_fields {
  buyFee: Float
  chainId: Float
  maxBuyFee: Float
  maxSellFee: Float
  pendingRedemptionCOL: Float
  pendingRedemptionUSD: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
}

"""
Streaming cursor of the table "OraclePriceFM"
"""
input OraclePriceFM_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: OraclePriceFM_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input OraclePriceFM_stream_cursor_value_input {
  address: String
  buyFee: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  externalPriceSetter_id: String
  id: String
  issuanceToken_id: String
  maxBuyFee: numeric
  maxSellFee: numeric
  pendingRedemptionCOL: numeric
  pendingRedemptionUSD: numeric
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
  treasury: String
  workflow_id: String
}

"""aggregate sum on columns"""
type OraclePriceFM_sum_fields {
  buyFee: numeric
  chainId: Int
  maxBuyFee: numeric
  maxSellFee: numeric
  pendingRedemptionCOL: numeric
  pendingRedemptionUSD: numeric
  reserveCOL: numeric
  reserveUSD: numeric
  sellFee: numeric
}

"""aggregate var_pop on columns"""
type OraclePriceFM_var_pop_fields {
  buyFee: Float
  chainId: Float
  maxBuyFee: Float
  maxSellFee: Float
  pendingRedemptionCOL: Float
  pendingRedemptionUSD: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
}

"""aggregate var_samp on columns"""
type OraclePriceFM_var_samp_fields {
  buyFee: Float
  chainId: Float
  maxBuyFee: Float
  maxSellFee: Float
  pendingRedemptionCOL: Float
  pendingRedemptionUSD: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
}

"""aggregate variance on columns"""
type OraclePriceFM_variance_fields {
  buyFee: Float
  chainId: Float
  maxBuyFee: Float
  maxSellFee: Float
  pendingRedemptionCOL: Float
  pendingRedemptionUSD: Float
  reserveCOL: Float
  reserveUSD: Float
  sellFee: Float
}

"""
columns and relationships of "OraclePriceOrder"
"""
type OraclePriceOrder {
  amountCOL: numeric!
  amountISS: numeric!
  amountUSD: numeric!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  db_write_timestamp: timestamp
  executedBy: String
  executedTimestamp: Int
  id: String!
  initiator: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!

  """An object relationship"""
  oraclePriceFM: OraclePriceFM
  oraclePriceFM_id: String!
  orderId: numeric
  orderType: paymentordertype
  priceCOL: numeric!
  priceUSD: numeric!

  """An object relationship"""
  projectFee: ProjectFee
  projectFee_id: String!

  """An object relationship"""
  protocolFee: ProtocolFee
  protocolFee_id: String!
  recipient: String!
  state: redemptionstate
  swapType: swaptype!
  targetChainId: Int
  timestamp: Int!
  txHash: String!
}

"""
order by aggregate values of table "OraclePriceOrder"
"""
input OraclePriceOrder_aggregate_order_by {
  avg: OraclePriceOrder_avg_order_by
  count: order_by
  max: OraclePriceOrder_max_order_by
  min: OraclePriceOrder_min_order_by
  stddev: OraclePriceOrder_stddev_order_by
  stddev_pop: OraclePriceOrder_stddev_pop_order_by
  stddev_samp: OraclePriceOrder_stddev_samp_order_by
  sum: OraclePriceOrder_sum_order_by
  var_pop: OraclePriceOrder_var_pop_order_by
  var_samp: OraclePriceOrder_var_samp_order_by
  variance: OraclePriceOrder_variance_order_by
}

"""
order by avg() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_avg_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "OraclePriceOrder". All fields are combined with a logical 'AND'.
"""
input OraclePriceOrder_bool_exp {
  _and: [OraclePriceOrder_bool_exp!]
  _not: OraclePriceOrder_bool_exp
  _or: [OraclePriceOrder_bool_exp!]
  amountCOL: numeric_comparison_exp
  amountISS: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  executedBy: String_comparison_exp
  executedTimestamp: Int_comparison_exp
  id: String_comparison_exp
  initiator: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  oraclePriceFM: OraclePriceFM_bool_exp
  oraclePriceFM_id: String_comparison_exp
  orderId: numeric_comparison_exp
  orderType: paymentordertype_comparison_exp
  priceCOL: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  projectFee: ProjectFee_bool_exp
  projectFee_id: String_comparison_exp
  protocolFee: ProtocolFee_bool_exp
  protocolFee_id: String_comparison_exp
  recipient: String_comparison_exp
  state: redemptionstate_comparison_exp
  swapType: swaptype_comparison_exp
  targetChainId: Int_comparison_exp
  timestamp: Int_comparison_exp
  txHash: String_comparison_exp
}

"""
order by max() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_max_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  executedBy: order_by
  executedTimestamp: order_by
  id: order_by
  initiator: order_by
  issuanceToken_id: order_by
  oraclePriceFM_id: order_by
  orderId: order_by
  orderType: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFee_id: order_by
  protocolFee_id: order_by
  recipient: order_by
  state: order_by
  swapType: order_by
  targetChainId: order_by
  timestamp: order_by
  txHash: order_by
}

"""
order by min() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_min_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  executedBy: order_by
  executedTimestamp: order_by
  id: order_by
  initiator: order_by
  issuanceToken_id: order_by
  oraclePriceFM_id: order_by
  orderId: order_by
  orderType: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFee_id: order_by
  protocolFee_id: order_by
  recipient: order_by
  state: order_by
  swapType: order_by
  targetChainId: order_by
  timestamp: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "OraclePriceOrder"."""
input OraclePriceOrder_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  executedBy: order_by
  executedTimestamp: order_by
  id: order_by
  initiator: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  oraclePriceFM: OraclePriceFM_order_by
  oraclePriceFM_id: order_by
  orderId: order_by
  orderType: order_by
  priceCOL: order_by
  priceUSD: order_by
  projectFee: ProjectFee_order_by
  projectFee_id: order_by
  protocolFee: ProtocolFee_order_by
  protocolFee_id: order_by
  recipient: order_by
  state: order_by
  swapType: order_by
  targetChainId: order_by
  timestamp: order_by
  txHash: order_by
}

"""
select columns of table "OraclePriceOrder"
"""
enum OraclePriceOrder_select_column {
  """column name"""
  amountCOL

  """column name"""
  amountISS

  """column name"""
  amountUSD

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  executedBy

  """column name"""
  executedTimestamp

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  issuanceToken_id

  """column name"""
  oraclePriceFM_id

  """column name"""
  orderId

  """column name"""
  orderType

  """column name"""
  priceCOL

  """column name"""
  priceUSD

  """column name"""
  projectFee_id

  """column name"""
  protocolFee_id

  """column name"""
  recipient

  """column name"""
  state

  """column name"""
  swapType

  """column name"""
  targetChainId

  """column name"""
  timestamp

  """column name"""
  txHash
}

"""
order by stddev() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_stddev_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_stddev_pop_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_stddev_samp_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "OraclePriceOrder"
"""
input OraclePriceOrder_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: OraclePriceOrder_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input OraclePriceOrder_stream_cursor_value_input {
  amountCOL: numeric
  amountISS: numeric
  amountUSD: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  executedBy: String
  executedTimestamp: Int
  id: String
  initiator: String
  issuanceToken_id: String
  oraclePriceFM_id: String
  orderId: numeric
  orderType: paymentordertype
  priceCOL: numeric
  priceUSD: numeric
  projectFee_id: String
  protocolFee_id: String
  recipient: String
  state: redemptionstate
  swapType: swaptype
  targetChainId: Int
  timestamp: Int
  txHash: String
}

"""
order by sum() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_sum_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_var_pop_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_var_samp_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "OraclePriceOrder"
"""
input OraclePriceOrder_variance_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  executedTimestamp: order_by
  orderId: order_by
  priceCOL: order_by
  priceUSD: order_by
  targetChainId: order_by
  timestamp: order_by
}

"""
columns and relationships of "ProjectFee"
"""
type ProjectFee {
  amount: numeric!
  amountUSD: numeric!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  module_id: String!
  recipient: String!
  timestamp: Int!

  """An object relationship"""
  token: Token
  token_id: String!
  txHash: String!
}

"""
aggregated selection of "ProjectFee"
"""
type ProjectFee_aggregate {
  aggregate: ProjectFee_aggregate_fields
  nodes: [ProjectFee!]!
}

input ProjectFee_aggregate_bool_exp {
  count: ProjectFee_aggregate_bool_exp_count
}

input ProjectFee_aggregate_bool_exp_count {
  arguments: [ProjectFee_select_column!]
  distinct: Boolean
  filter: ProjectFee_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ProjectFee"
"""
type ProjectFee_aggregate_fields {
  avg: ProjectFee_avg_fields
  count(columns: [ProjectFee_select_column!], distinct: Boolean): Int!
  max: ProjectFee_max_fields
  min: ProjectFee_min_fields
  stddev: ProjectFee_stddev_fields
  stddev_pop: ProjectFee_stddev_pop_fields
  stddev_samp: ProjectFee_stddev_samp_fields
  sum: ProjectFee_sum_fields
  var_pop: ProjectFee_var_pop_fields
  var_samp: ProjectFee_var_samp_fields
  variance: ProjectFee_variance_fields
}

"""
order by aggregate values of table "ProjectFee"
"""
input ProjectFee_aggregate_order_by {
  avg: ProjectFee_avg_order_by
  count: order_by
  max: ProjectFee_max_order_by
  min: ProjectFee_min_order_by
  stddev: ProjectFee_stddev_order_by
  stddev_pop: ProjectFee_stddev_pop_order_by
  stddev_samp: ProjectFee_stddev_samp_order_by
  sum: ProjectFee_sum_order_by
  var_pop: ProjectFee_var_pop_order_by
  var_samp: ProjectFee_var_samp_order_by
  variance: ProjectFee_variance_order_by
}

"""aggregate avg on columns"""
type ProjectFee_avg_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by avg() on columns of table "ProjectFee"
"""
input ProjectFee_avg_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "ProjectFee". All fields are combined with a logical 'AND'.
"""
input ProjectFee_bool_exp {
  _and: [ProjectFee_bool_exp!]
  _not: ProjectFee_bool_exp
  _or: [ProjectFee_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  module_id: String_comparison_exp
  recipient: String_comparison_exp
  timestamp: Int_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  txHash: String_comparison_exp
}

"""aggregate max on columns"""
type ProjectFee_max_fields {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  recipient: String
  timestamp: Int
  token_id: String
  txHash: String
}

"""
order by max() on columns of table "ProjectFee"
"""
input ProjectFee_max_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  recipient: order_by
  timestamp: order_by
  token_id: order_by
  txHash: order_by
}

"""aggregate min on columns"""
type ProjectFee_min_fields {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  recipient: String
  timestamp: Int
  token_id: String
  txHash: String
}

"""
order by min() on columns of table "ProjectFee"
"""
input ProjectFee_min_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  recipient: order_by
  timestamp: order_by
  token_id: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "ProjectFee"."""
input ProjectFee_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  recipient: order_by
  timestamp: order_by
  token: Token_order_by
  token_id: order_by
  txHash: order_by
}

"""
select columns of table "ProjectFee"
"""
enum ProjectFee_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  module_id

  """column name"""
  recipient

  """column name"""
  timestamp

  """column name"""
  token_id

  """column name"""
  txHash
}

"""aggregate stddev on columns"""
type ProjectFee_stddev_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by stddev() on columns of table "ProjectFee"
"""
input ProjectFee_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate stddev_pop on columns"""
type ProjectFee_stddev_pop_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by stddev_pop() on columns of table "ProjectFee"
"""
input ProjectFee_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate stddev_samp on columns"""
type ProjectFee_stddev_samp_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by stddev_samp() on columns of table "ProjectFee"
"""
input ProjectFee_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "ProjectFee"
"""
input ProjectFee_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ProjectFee_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ProjectFee_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  recipient: String
  timestamp: Int
  token_id: String
  txHash: String
}

"""aggregate sum on columns"""
type ProjectFee_sum_fields {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  timestamp: Int
}

"""
order by sum() on columns of table "ProjectFee"
"""
input ProjectFee_sum_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate var_pop on columns"""
type ProjectFee_var_pop_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by var_pop() on columns of table "ProjectFee"
"""
input ProjectFee_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate var_samp on columns"""
type ProjectFee_var_samp_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by var_samp() on columns of table "ProjectFee"
"""
input ProjectFee_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate variance on columns"""
type ProjectFee_variance_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by variance() on columns of table "ProjectFee"
"""
input ProjectFee_variance_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""
columns and relationships of "ProtocolFee"
"""
type ProtocolFee {
  amount: numeric!
  amountUSD: numeric!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  module_id: String!
  source: sourcetokentype!
  timestamp: Int!

  """An object relationship"""
  token: Token
  token_id: String!
  treasury: String!
  txHash: String!
}

"""
aggregated selection of "ProtocolFee"
"""
type ProtocolFee_aggregate {
  aggregate: ProtocolFee_aggregate_fields
  nodes: [ProtocolFee!]!
}

input ProtocolFee_aggregate_bool_exp {
  count: ProtocolFee_aggregate_bool_exp_count
}

input ProtocolFee_aggregate_bool_exp_count {
  arguments: [ProtocolFee_select_column!]
  distinct: Boolean
  filter: ProtocolFee_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ProtocolFee"
"""
type ProtocolFee_aggregate_fields {
  avg: ProtocolFee_avg_fields
  count(columns: [ProtocolFee_select_column!], distinct: Boolean): Int!
  max: ProtocolFee_max_fields
  min: ProtocolFee_min_fields
  stddev: ProtocolFee_stddev_fields
  stddev_pop: ProtocolFee_stddev_pop_fields
  stddev_samp: ProtocolFee_stddev_samp_fields
  sum: ProtocolFee_sum_fields
  var_pop: ProtocolFee_var_pop_fields
  var_samp: ProtocolFee_var_samp_fields
  variance: ProtocolFee_variance_fields
}

"""
order by aggregate values of table "ProtocolFee"
"""
input ProtocolFee_aggregate_order_by {
  avg: ProtocolFee_avg_order_by
  count: order_by
  max: ProtocolFee_max_order_by
  min: ProtocolFee_min_order_by
  stddev: ProtocolFee_stddev_order_by
  stddev_pop: ProtocolFee_stddev_pop_order_by
  stddev_samp: ProtocolFee_stddev_samp_order_by
  sum: ProtocolFee_sum_order_by
  var_pop: ProtocolFee_var_pop_order_by
  var_samp: ProtocolFee_var_samp_order_by
  variance: ProtocolFee_variance_order_by
}

"""aggregate avg on columns"""
type ProtocolFee_avg_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by avg() on columns of table "ProtocolFee"
"""
input ProtocolFee_avg_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "ProtocolFee". All fields are combined with a logical 'AND'.
"""
input ProtocolFee_bool_exp {
  _and: [ProtocolFee_bool_exp!]
  _not: ProtocolFee_bool_exp
  _or: [ProtocolFee_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  module_id: String_comparison_exp
  source: sourcetokentype_comparison_exp
  timestamp: Int_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
  treasury: String_comparison_exp
  txHash: String_comparison_exp
}

"""aggregate max on columns"""
type ProtocolFee_max_fields {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  source: sourcetokentype
  timestamp: Int
  token_id: String
  treasury: String
  txHash: String
}

"""
order by max() on columns of table "ProtocolFee"
"""
input ProtocolFee_max_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  source: order_by
  timestamp: order_by
  token_id: order_by
  treasury: order_by
  txHash: order_by
}

"""aggregate min on columns"""
type ProtocolFee_min_fields {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  source: sourcetokentype
  timestamp: Int
  token_id: String
  treasury: String
  txHash: String
}

"""
order by min() on columns of table "ProtocolFee"
"""
input ProtocolFee_min_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  source: order_by
  timestamp: order_by
  token_id: order_by
  treasury: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "ProtocolFee"."""
input ProtocolFee_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  module_id: order_by
  source: order_by
  timestamp: order_by
  token: Token_order_by
  token_id: order_by
  treasury: order_by
  txHash: order_by
}

"""
select columns of table "ProtocolFee"
"""
enum ProtocolFee_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  module_id

  """column name"""
  source

  """column name"""
  timestamp

  """column name"""
  token_id

  """column name"""
  treasury

  """column name"""
  txHash
}

"""aggregate stddev on columns"""
type ProtocolFee_stddev_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by stddev() on columns of table "ProtocolFee"
"""
input ProtocolFee_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate stddev_pop on columns"""
type ProtocolFee_stddev_pop_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by stddev_pop() on columns of table "ProtocolFee"
"""
input ProtocolFee_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate stddev_samp on columns"""
type ProtocolFee_stddev_samp_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by stddev_samp() on columns of table "ProtocolFee"
"""
input ProtocolFee_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "ProtocolFee"
"""
input ProtocolFee_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ProtocolFee_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ProtocolFee_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  module_id: String
  source: sourcetokentype
  timestamp: Int
  token_id: String
  treasury: String
  txHash: String
}

"""aggregate sum on columns"""
type ProtocolFee_sum_fields {
  amount: numeric
  amountUSD: numeric
  chainId: Int
  timestamp: Int
}

"""
order by sum() on columns of table "ProtocolFee"
"""
input ProtocolFee_sum_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate var_pop on columns"""
type ProtocolFee_var_pop_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by var_pop() on columns of table "ProtocolFee"
"""
input ProtocolFee_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate var_samp on columns"""
type ProtocolFee_var_samp_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by var_samp() on columns of table "ProtocolFee"
"""
input ProtocolFee_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""aggregate variance on columns"""
type ProtocolFee_variance_fields {
  amount: Float
  amountUSD: Float
  chainId: Float
  timestamp: Float
}

"""
order by variance() on columns of table "ProtocolFee"
"""
input ProtocolFee_variance_order_by {
  amount: order_by
  amountUSD: order_by
  chainId: order_by
  timestamp: order_by
}

"""
columns and relationships of "Role"
"""
type Role {
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  initiator: String!
  module_id: String!
  recipient: String!
  role: String
  roleGen: String!
  roleName: String
  status: rolestatus!
  timestamp: Int!
  txHash: String!
}

"""
order by aggregate values of table "Role"
"""
input Role_aggregate_order_by {
  avg: Role_avg_order_by
  count: order_by
  max: Role_max_order_by
  min: Role_min_order_by
  stddev: Role_stddev_order_by
  stddev_pop: Role_stddev_pop_order_by
  stddev_samp: Role_stddev_samp_order_by
  sum: Role_sum_order_by
  var_pop: Role_var_pop_order_by
  var_samp: Role_var_samp_order_by
  variance: Role_variance_order_by
}

"""
order by avg() on columns of table "Role"
"""
input Role_avg_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "Role". All fields are combined with a logical 'AND'.
"""
input Role_bool_exp {
  _and: [Role_bool_exp!]
  _not: Role_bool_exp
  _or: [Role_bool_exp!]
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  initiator: String_comparison_exp
  module_id: String_comparison_exp
  recipient: String_comparison_exp
  role: String_comparison_exp
  roleGen: String_comparison_exp
  roleName: String_comparison_exp
  status: rolestatus_comparison_exp
  timestamp: Int_comparison_exp
  txHash: String_comparison_exp
}

"""
order by max() on columns of table "Role"
"""
input Role_max_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  module_id: order_by
  recipient: order_by
  role: order_by
  roleGen: order_by
  roleName: order_by
  status: order_by
  timestamp: order_by
  txHash: order_by
}

"""
order by min() on columns of table "Role"
"""
input Role_min_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  module_id: order_by
  recipient: order_by
  role: order_by
  roleGen: order_by
  roleName: order_by
  status: order_by
  timestamp: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "Role"."""
input Role_order_by {
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  initiator: order_by
  module_id: order_by
  recipient: order_by
  role: order_by
  roleGen: order_by
  roleName: order_by
  status: order_by
  timestamp: order_by
  txHash: order_by
}

"""
select columns of table "Role"
"""
enum Role_select_column {
  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  module_id

  """column name"""
  recipient

  """column name"""
  role

  """column name"""
  roleGen

  """column name"""
  roleName

  """column name"""
  status

  """column name"""
  timestamp

  """column name"""
  txHash
}

"""
order by stddev() on columns of table "Role"
"""
input Role_stddev_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "Role"
"""
input Role_stddev_pop_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "Role"
"""
input Role_stddev_samp_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "Role"
"""
input Role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Role_stream_cursor_value_input {
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  initiator: String
  module_id: String
  recipient: String
  role: String
  roleGen: String
  roleName: String
  status: rolestatus
  timestamp: Int
  txHash: String
}

"""
order by sum() on columns of table "Role"
"""
input Role_sum_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "Role"
"""
input Role_var_pop_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "Role"
"""
input Role_var_samp_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "Role"
"""
input Role_variance_order_by {
  chainId: order_by
  timestamp: order_by
}

"""
columns and relationships of "StreamingPaymentProcessor"
"""
type StreamingPaymentProcessor {
  address: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An array relationship"""
  vestings(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """An object relationship"""
  workflow: Workflow
  workflow_id: String!
}

"""
Boolean expression to filter rows from the table "StreamingPaymentProcessor". All fields are combined with a logical 'AND'.
"""
input StreamingPaymentProcessor_bool_exp {
  _and: [StreamingPaymentProcessor_bool_exp!]
  _not: StreamingPaymentProcessor_bool_exp
  _or: [StreamingPaymentProcessor_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  vestings: LinearVesting_bool_exp
  workflow: Workflow_bool_exp
  workflow_id: String_comparison_exp
}

"""Ordering options when selecting data from "StreamingPaymentProcessor"."""
input StreamingPaymentProcessor_order_by {
  address: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  vestings_aggregate: LinearVesting_aggregate_order_by
  workflow: Workflow_order_by
  workflow_id: order_by
}

"""
select columns of table "StreamingPaymentProcessor"
"""
enum StreamingPaymentProcessor_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  workflow_id
}

"""
Streaming cursor of the table "StreamingPaymentProcessor"
"""
input StreamingPaymentProcessor_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: StreamingPaymentProcessor_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input StreamingPaymentProcessor_stream_cursor_value_input {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  workflow_id: String
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "Swap"
"""
type Swap {
  amountCOL: numeric!
  amountISS: numeric!
  amountUSD: numeric!
  chainId: Int!

  """An object relationship"""
  collateralToken: Token
  collateralToken_id: String!
  db_write_timestamp: timestamp
  fundingManager_id: String!
  id: String!
  initiator: String!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!
  priceCOL: numeric!
  priceUSD: numeric!
  recipient: String!
  swapType: swaptype!
  timestamp: Int!
  txHash: String!
}

"""
order by aggregate values of table "Swap"
"""
input Swap_aggregate_order_by {
  avg: Swap_avg_order_by
  count: order_by
  max: Swap_max_order_by
  min: Swap_min_order_by
  stddev: Swap_stddev_order_by
  stddev_pop: Swap_stddev_pop_order_by
  stddev_samp: Swap_stddev_samp_order_by
  sum: Swap_sum_order_by
  var_pop: Swap_var_pop_order_by
  var_samp: Swap_var_samp_order_by
  variance: Swap_variance_order_by
}

"""
order by avg() on columns of table "Swap"
"""
input Swap_avg_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "Swap". All fields are combined with a logical 'AND'.
"""
input Swap_bool_exp {
  _and: [Swap_bool_exp!]
  _not: Swap_bool_exp
  _or: [Swap_bool_exp!]
  amountCOL: numeric_comparison_exp
  amountISS: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  chainId: Int_comparison_exp
  collateralToken: Token_bool_exp
  collateralToken_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  fundingManager_id: String_comparison_exp
  id: String_comparison_exp
  initiator: String_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  priceCOL: numeric_comparison_exp
  priceUSD: numeric_comparison_exp
  recipient: String_comparison_exp
  swapType: swaptype_comparison_exp
  timestamp: Int_comparison_exp
  txHash: String_comparison_exp
}

"""
order by max() on columns of table "Swap"
"""
input Swap_max_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  id: order_by
  initiator: order_by
  issuanceToken_id: order_by
  priceCOL: order_by
  priceUSD: order_by
  recipient: order_by
  swapType: order_by
  timestamp: order_by
  txHash: order_by
}

"""
order by min() on columns of table "Swap"
"""
input Swap_min_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  id: order_by
  initiator: order_by
  issuanceToken_id: order_by
  priceCOL: order_by
  priceUSD: order_by
  recipient: order_by
  swapType: order_by
  timestamp: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "Swap"."""
input Swap_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  collateralToken: Token_order_by
  collateralToken_id: order_by
  db_write_timestamp: order_by
  fundingManager_id: order_by
  id: order_by
  initiator: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  priceCOL: order_by
  priceUSD: order_by
  recipient: order_by
  swapType: order_by
  timestamp: order_by
  txHash: order_by
}

"""
select columns of table "Swap"
"""
enum Swap_select_column {
  """column name"""
  amountCOL

  """column name"""
  amountISS

  """column name"""
  amountUSD

  """column name"""
  chainId

  """column name"""
  collateralToken_id

  """column name"""
  db_write_timestamp

  """column name"""
  fundingManager_id

  """column name"""
  id

  """column name"""
  initiator

  """column name"""
  issuanceToken_id

  """column name"""
  priceCOL

  """column name"""
  priceUSD

  """column name"""
  recipient

  """column name"""
  swapType

  """column name"""
  timestamp

  """column name"""
  txHash
}

"""
order by stddev() on columns of table "Swap"
"""
input Swap_stddev_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "Swap"
"""
input Swap_stddev_pop_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "Swap"
"""
input Swap_stddev_samp_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "Swap"
"""
input Swap_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Swap_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Swap_stream_cursor_value_input {
  amountCOL: numeric
  amountISS: numeric
  amountUSD: numeric
  chainId: Int
  collateralToken_id: String
  db_write_timestamp: timestamp
  fundingManager_id: String
  id: String
  initiator: String
  issuanceToken_id: String
  priceCOL: numeric
  priceUSD: numeric
  recipient: String
  swapType: swaptype
  timestamp: Int
  txHash: String
}

"""
order by sum() on columns of table "Swap"
"""
input Swap_sum_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "Swap"
"""
input Swap_var_pop_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "Swap"
"""
input Swap_var_samp_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "Swap"
"""
input Swap_variance_order_by {
  amountCOL: order_by
  amountISS: order_by
  amountUSD: order_by
  chainId: order_by
  priceCOL: order_by
  priceUSD: order_by
  timestamp: order_by
}

"""
columns and relationships of "Token"
"""
type Token {
  address: String!
  chainId: Int!
  db_write_timestamp: timestamp
  decimals: Int!
  id: String!
  name: String!
  priceUSD: numeric!
  symbol: String!
  totalSupply: numeric!
}

"""
aggregated selection of "Token"
"""
type Token_aggregate {
  aggregate: Token_aggregate_fields
  nodes: [Token!]!
}

"""
aggregate fields of "Token"
"""
type Token_aggregate_fields {
  avg: Token_avg_fields
  count(columns: [Token_select_column!], distinct: Boolean): Int!
  max: Token_max_fields
  min: Token_min_fields
  stddev: Token_stddev_fields
  stddev_pop: Token_stddev_pop_fields
  stddev_samp: Token_stddev_samp_fields
  sum: Token_sum_fields
  var_pop: Token_var_pop_fields
  var_samp: Token_var_samp_fields
  variance: Token_variance_fields
}

"""aggregate avg on columns"""
type Token_avg_fields {
  chainId: Float
  decimals: Float
  priceUSD: Float
  totalSupply: Float
}

"""
Boolean expression to filter rows from the table "Token". All fields are combined with a logical 'AND'.
"""
input Token_bool_exp {
  _and: [Token_bool_exp!]
  _not: Token_bool_exp
  _or: [Token_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  decimals: Int_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  priceUSD: numeric_comparison_exp
  symbol: String_comparison_exp
  totalSupply: numeric_comparison_exp
}

"""aggregate max on columns"""
type Token_max_fields {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  decimals: Int
  id: String
  name: String
  priceUSD: numeric
  symbol: String
  totalSupply: numeric
}

"""aggregate min on columns"""
type Token_min_fields {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  decimals: Int
  id: String
  name: String
  priceUSD: numeric
  symbol: String
  totalSupply: numeric
}

"""Ordering options when selecting data from "Token"."""
input Token_order_by {
  address: order_by
  chainId: order_by
  db_write_timestamp: order_by
  decimals: order_by
  id: order_by
  name: order_by
  priceUSD: order_by
  symbol: order_by
  totalSupply: order_by
}

"""
select columns of table "Token"
"""
enum Token_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  decimals

  """column name"""
  id

  """column name"""
  name

  """column name"""
  priceUSD

  """column name"""
  symbol

  """column name"""
  totalSupply
}

"""aggregate stddev on columns"""
type Token_stddev_fields {
  chainId: Float
  decimals: Float
  priceUSD: Float
  totalSupply: Float
}

"""aggregate stddev_pop on columns"""
type Token_stddev_pop_fields {
  chainId: Float
  decimals: Float
  priceUSD: Float
  totalSupply: Float
}

"""aggregate stddev_samp on columns"""
type Token_stddev_samp_fields {
  chainId: Float
  decimals: Float
  priceUSD: Float
  totalSupply: Float
}

"""
Streaming cursor of the table "Token"
"""
input Token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Token_stream_cursor_value_input {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  decimals: Int
  id: String
  name: String
  priceUSD: numeric
  symbol: String
  totalSupply: numeric
}

"""aggregate sum on columns"""
type Token_sum_fields {
  chainId: Int
  decimals: Int
  priceUSD: numeric
  totalSupply: numeric
}

"""aggregate var_pop on columns"""
type Token_var_pop_fields {
  chainId: Float
  decimals: Float
  priceUSD: Float
  totalSupply: Float
}

"""aggregate var_samp on columns"""
type Token_var_samp_fields {
  chainId: Float
  decimals: Float
  priceUSD: Float
  totalSupply: Float
}

"""aggregate variance on columns"""
type Token_variance_fields {
  chainId: Float
  decimals: Float
  priceUSD: Float
  totalSupply: Float
}

"""
columns and relationships of "Transfer"
"""
type Transfer {
  amount: numeric!
  amountUSD: numeric!
  db_write_timestamp: timestamp

  """An object relationship"""
  depositVault: DepositVault
  depositVault_id: String!
  id: String!
  recipient: String!
  timestamp: Int!
  txHash: String!
}

"""
aggregated selection of "Transfer"
"""
type Transfer_aggregate {
  aggregate: Transfer_aggregate_fields
  nodes: [Transfer!]!
}

input Transfer_aggregate_bool_exp {
  count: Transfer_aggregate_bool_exp_count
}

input Transfer_aggregate_bool_exp_count {
  arguments: [Transfer_select_column!]
  distinct: Boolean
  filter: Transfer_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "Transfer"
"""
type Transfer_aggregate_fields {
  avg: Transfer_avg_fields
  count(columns: [Transfer_select_column!], distinct: Boolean): Int!
  max: Transfer_max_fields
  min: Transfer_min_fields
  stddev: Transfer_stddev_fields
  stddev_pop: Transfer_stddev_pop_fields
  stddev_samp: Transfer_stddev_samp_fields
  sum: Transfer_sum_fields
  var_pop: Transfer_var_pop_fields
  var_samp: Transfer_var_samp_fields
  variance: Transfer_variance_fields
}

"""
order by aggregate values of table "Transfer"
"""
input Transfer_aggregate_order_by {
  avg: Transfer_avg_order_by
  count: order_by
  max: Transfer_max_order_by
  min: Transfer_min_order_by
  stddev: Transfer_stddev_order_by
  stddev_pop: Transfer_stddev_pop_order_by
  stddev_samp: Transfer_stddev_samp_order_by
  sum: Transfer_sum_order_by
  var_pop: Transfer_var_pop_order_by
  var_samp: Transfer_var_samp_order_by
  variance: Transfer_variance_order_by
}

"""aggregate avg on columns"""
type Transfer_avg_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by avg() on columns of table "Transfer"
"""
input Transfer_avg_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "Transfer". All fields are combined with a logical 'AND'.
"""
input Transfer_bool_exp {
  _and: [Transfer_bool_exp!]
  _not: Transfer_bool_exp
  _or: [Transfer_bool_exp!]
  amount: numeric_comparison_exp
  amountUSD: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  depositVault: DepositVault_bool_exp
  depositVault_id: String_comparison_exp
  id: String_comparison_exp
  recipient: String_comparison_exp
  timestamp: Int_comparison_exp
  txHash: String_comparison_exp
}

"""aggregate max on columns"""
type Transfer_max_fields {
  amount: numeric
  amountUSD: numeric
  db_write_timestamp: timestamp
  depositVault_id: String
  id: String
  recipient: String
  timestamp: Int
  txHash: String
}

"""
order by max() on columns of table "Transfer"
"""
input Transfer_max_order_by {
  amount: order_by
  amountUSD: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  id: order_by
  recipient: order_by
  timestamp: order_by
  txHash: order_by
}

"""aggregate min on columns"""
type Transfer_min_fields {
  amount: numeric
  amountUSD: numeric
  db_write_timestamp: timestamp
  depositVault_id: String
  id: String
  recipient: String
  timestamp: Int
  txHash: String
}

"""
order by min() on columns of table "Transfer"
"""
input Transfer_min_order_by {
  amount: order_by
  amountUSD: order_by
  db_write_timestamp: order_by
  depositVault_id: order_by
  id: order_by
  recipient: order_by
  timestamp: order_by
  txHash: order_by
}

"""Ordering options when selecting data from "Transfer"."""
input Transfer_order_by {
  amount: order_by
  amountUSD: order_by
  db_write_timestamp: order_by
  depositVault: DepositVault_order_by
  depositVault_id: order_by
  id: order_by
  recipient: order_by
  timestamp: order_by
  txHash: order_by
}

"""
select columns of table "Transfer"
"""
enum Transfer_select_column {
  """column name"""
  amount

  """column name"""
  amountUSD

  """column name"""
  db_write_timestamp

  """column name"""
  depositVault_id

  """column name"""
  id

  """column name"""
  recipient

  """column name"""
  timestamp

  """column name"""
  txHash
}

"""aggregate stddev on columns"""
type Transfer_stddev_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by stddev() on columns of table "Transfer"
"""
input Transfer_stddev_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate stddev_pop on columns"""
type Transfer_stddev_pop_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by stddev_pop() on columns of table "Transfer"
"""
input Transfer_stddev_pop_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate stddev_samp on columns"""
type Transfer_stddev_samp_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by stddev_samp() on columns of table "Transfer"
"""
input Transfer_stddev_samp_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "Transfer"
"""
input Transfer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Transfer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Transfer_stream_cursor_value_input {
  amount: numeric
  amountUSD: numeric
  db_write_timestamp: timestamp
  depositVault_id: String
  id: String
  recipient: String
  timestamp: Int
  txHash: String
}

"""aggregate sum on columns"""
type Transfer_sum_fields {
  amount: numeric
  amountUSD: numeric
  timestamp: Int
}

"""
order by sum() on columns of table "Transfer"
"""
input Transfer_sum_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate var_pop on columns"""
type Transfer_var_pop_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by var_pop() on columns of table "Transfer"
"""
input Transfer_var_pop_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate var_samp on columns"""
type Transfer_var_samp_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by var_samp() on columns of table "Transfer"
"""
input Transfer_var_samp_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""aggregate variance on columns"""
type Transfer_variance_fields {
  amount: Float
  amountUSD: Float
  timestamp: Float
}

"""
order by variance() on columns of table "Transfer"
"""
input Transfer_variance_order_by {
  amount: order_by
  amountUSD: order_by
  timestamp: order_by
}

"""
columns and relationships of "Workflow"
"""
type Workflow {
  address: String!

  """An object relationship"""
  authorizer: WorkflowModule
  authorizer_id: String!
  chainId: Int!
  db_write_timestamp: timestamp

  """An object relationship"""
  fundingManager: WorkflowModule
  fundingManager_id: String!
  id: String!
  optionalModules: [String!]
  orchestrator: String!

  """An object relationship"""
  paymentProcessor: WorkflowModule
  paymentProcessor_id: String!

  """An object relationship"""
  token: Token
  token_id: String!
}

"""
columns and relationships of "WorkflowModule"
"""
type WorkflowModule {
  address: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!

  """An object relationship"""
  moduleType: WorkflowModuleType
  moduleType_id: String!
  orchestrator: String!
}

"""
columns and relationships of "WorkflowModuleType"
"""
type WorkflowModuleType {
  beacon: String!
  chainId: Int!
  db_write_timestamp: timestamp
  id: String!
  majorVersion: numeric!
  minorVersion: numeric!
  name: String!
  patchVersion: numeric!
  url: String!
}

"""
Boolean expression to filter rows from the table "WorkflowModuleType". All fields are combined with a logical 'AND'.
"""
input WorkflowModuleType_bool_exp {
  _and: [WorkflowModuleType_bool_exp!]
  _not: WorkflowModuleType_bool_exp
  _or: [WorkflowModuleType_bool_exp!]
  beacon: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  majorVersion: numeric_comparison_exp
  minorVersion: numeric_comparison_exp
  name: String_comparison_exp
  patchVersion: numeric_comparison_exp
  url: String_comparison_exp
}

"""Ordering options when selecting data from "WorkflowModuleType"."""
input WorkflowModuleType_order_by {
  beacon: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  majorVersion: order_by
  minorVersion: order_by
  name: order_by
  patchVersion: order_by
  url: order_by
}

"""
select columns of table "WorkflowModuleType"
"""
enum WorkflowModuleType_select_column {
  """column name"""
  beacon

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  majorVersion

  """column name"""
  minorVersion

  """column name"""
  name

  """column name"""
  patchVersion

  """column name"""
  url
}

"""
Streaming cursor of the table "WorkflowModuleType"
"""
input WorkflowModuleType_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: WorkflowModuleType_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input WorkflowModuleType_stream_cursor_value_input {
  beacon: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  majorVersion: numeric
  minorVersion: numeric
  name: String
  patchVersion: numeric
  url: String
}

"""
Boolean expression to filter rows from the table "WorkflowModule". All fields are combined with a logical 'AND'.
"""
input WorkflowModule_bool_exp {
  _and: [WorkflowModule_bool_exp!]
  _not: WorkflowModule_bool_exp
  _or: [WorkflowModule_bool_exp!]
  address: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  moduleType: WorkflowModuleType_bool_exp
  moduleType_id: String_comparison_exp
  orchestrator: String_comparison_exp
}

"""Ordering options when selecting data from "WorkflowModule"."""
input WorkflowModule_order_by {
  address: order_by
  chainId: order_by
  db_write_timestamp: order_by
  id: order_by
  moduleType: WorkflowModuleType_order_by
  moduleType_id: order_by
  orchestrator: order_by
}

"""
select columns of table "WorkflowModule"
"""
enum WorkflowModule_select_column {
  """column name"""
  address

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  moduleType_id

  """column name"""
  orchestrator
}

"""
Streaming cursor of the table "WorkflowModule"
"""
input WorkflowModule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: WorkflowModule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input WorkflowModule_stream_cursor_value_input {
  address: String
  chainId: Int
  db_write_timestamp: timestamp
  id: String
  moduleType_id: String
  orchestrator: String
}

"""
Boolean expression to filter rows from the table "Workflow". All fields are combined with a logical 'AND'.
"""
input Workflow_bool_exp {
  _and: [Workflow_bool_exp!]
  _not: Workflow_bool_exp
  _or: [Workflow_bool_exp!]
  address: String_comparison_exp
  authorizer: WorkflowModule_bool_exp
  authorizer_id: String_comparison_exp
  chainId: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  fundingManager: WorkflowModule_bool_exp
  fundingManager_id: String_comparison_exp
  id: String_comparison_exp
  optionalModules: String_array_comparison_exp
  orchestrator: String_comparison_exp
  paymentProcessor: WorkflowModule_bool_exp
  paymentProcessor_id: String_comparison_exp
  token: Token_bool_exp
  token_id: String_comparison_exp
}

"""Ordering options when selecting data from "Workflow"."""
input Workflow_order_by {
  address: order_by
  authorizer: WorkflowModule_order_by
  authorizer_id: order_by
  chainId: order_by
  db_write_timestamp: order_by
  fundingManager: WorkflowModule_order_by
  fundingManager_id: order_by
  id: order_by
  optionalModules: order_by
  orchestrator: order_by
  paymentProcessor: WorkflowModule_order_by
  paymentProcessor_id: order_by
  token: Token_order_by
  token_id: order_by
}

"""
select columns of table "Workflow"
"""
enum Workflow_select_column {
  """column name"""
  address

  """column name"""
  authorizer_id

  """column name"""
  chainId

  """column name"""
  db_write_timestamp

  """column name"""
  fundingManager_id

  """column name"""
  id

  """column name"""
  optionalModules

  """column name"""
  orchestrator

  """column name"""
  paymentProcessor_id

  """column name"""
  token_id
}

"""
Streaming cursor of the table "Workflow"
"""
input Workflow_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Workflow_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Workflow_stream_cursor_value_input {
  address: String
  authorizer_id: String
  chainId: Int
  db_write_timestamp: timestamp
  fundingManager_id: String
  id: String
  optionalModules: [String!]
  orchestrator: String
  paymentProcessor_id: String
  token_id: String
}

"""
columns and relationships of "chain_metadata"
"""
type chain_metadata {
  block_height: Int!
  chain_id: Int!
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean!
  latest_fetched_block_number: Int!
  latest_processed_block: Int
  num_batches_fetched: Int!
  num_events_processed: Int
  start_block: Int!
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

"""
Boolean expression to filter rows from the table "chain_metadata". All fields are combined with a logical 'AND'.
"""
input chain_metadata_bool_exp {
  _and: [chain_metadata_bool_exp!]
  _not: chain_metadata_bool_exp
  _or: [chain_metadata_bool_exp!]
  block_height: Int_comparison_exp
  chain_id: Int_comparison_exp
  end_block: Int_comparison_exp
  first_event_block_number: Int_comparison_exp
  is_hyper_sync: Boolean_comparison_exp
  latest_fetched_block_number: Int_comparison_exp
  latest_processed_block: Int_comparison_exp
  num_batches_fetched: Int_comparison_exp
  num_events_processed: Int_comparison_exp
  start_block: Int_comparison_exp
  timestamp_caught_up_to_head_or_endblock: timestamptz_comparison_exp
}

"""Ordering options when selecting data from "chain_metadata"."""
input chain_metadata_order_by {
  block_height: order_by
  chain_id: order_by
  end_block: order_by
  first_event_block_number: order_by
  is_hyper_sync: order_by
  latest_fetched_block_number: order_by
  latest_processed_block: order_by
  num_batches_fetched: order_by
  num_events_processed: order_by
  start_block: order_by
  timestamp_caught_up_to_head_or_endblock: order_by
}

"""
select columns of table "chain_metadata"
"""
enum chain_metadata_select_column {
  """column name"""
  block_height

  """column name"""
  chain_id

  """column name"""
  end_block

  """column name"""
  first_event_block_number

  """column name"""
  is_hyper_sync

  """column name"""
  latest_fetched_block_number

  """column name"""
  latest_processed_block

  """column name"""
  num_batches_fetched

  """column name"""
  num_events_processed

  """column name"""
  start_block

  """column name"""
  timestamp_caught_up_to_head_or_endblock
}

"""
Streaming cursor of the table "chain_metadata"
"""
input chain_metadata_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chain_metadata_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chain_metadata_stream_cursor_value_input {
  block_height: Int
  chain_id: Int
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean
  latest_fetched_block_number: Int
  latest_processed_block: Int
  num_batches_fetched: Int
  num_events_processed: Int
  start_block: Int
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

scalar contract_type

"""
Boolean expression to compare columns of type "contract_type". All fields are combined with logical 'AND'.
"""
input contract_type_comparison_exp {
  _eq: contract_type
  _gt: contract_type
  _gte: contract_type
  _in: [contract_type!]
  _is_null: Boolean
  _lt: contract_type
  _lte: contract_type
  _neq: contract_type
  _nin: [contract_type!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "dynamic_contract_registry"
"""
type dynamic_contract_registry {
  chain_id: Int!
  contract_address: String!
  contract_type: contract_type!
  id: String!
  is_pre_registered: Boolean!
  registering_event_block_number: Int!
  registering_event_block_timestamp: Int!
  registering_event_contract_name: String!
  registering_event_log_index: Int!
  registering_event_name: String!
  registering_event_src_address: String!
}

"""
Boolean expression to filter rows from the table "dynamic_contract_registry". All fields are combined with a logical 'AND'.
"""
input dynamic_contract_registry_bool_exp {
  _and: [dynamic_contract_registry_bool_exp!]
  _not: dynamic_contract_registry_bool_exp
  _or: [dynamic_contract_registry_bool_exp!]
  chain_id: Int_comparison_exp
  contract_address: String_comparison_exp
  contract_type: contract_type_comparison_exp
  id: String_comparison_exp
  is_pre_registered: Boolean_comparison_exp
  registering_event_block_number: Int_comparison_exp
  registering_event_block_timestamp: Int_comparison_exp
  registering_event_contract_name: String_comparison_exp
  registering_event_log_index: Int_comparison_exp
  registering_event_name: String_comparison_exp
  registering_event_src_address: String_comparison_exp
}

"""Ordering options when selecting data from "dynamic_contract_registry"."""
input dynamic_contract_registry_order_by {
  chain_id: order_by
  contract_address: order_by
  contract_type: order_by
  id: order_by
  is_pre_registered: order_by
  registering_event_block_number: order_by
  registering_event_block_timestamp: order_by
  registering_event_contract_name: order_by
  registering_event_log_index: order_by
  registering_event_name: order_by
  registering_event_src_address: order_by
}

"""
select columns of table "dynamic_contract_registry"
"""
enum dynamic_contract_registry_select_column {
  """column name"""
  chain_id

  """column name"""
  contract_address

  """column name"""
  contract_type

  """column name"""
  id

  """column name"""
  is_pre_registered

  """column name"""
  registering_event_block_number

  """column name"""
  registering_event_block_timestamp

  """column name"""
  registering_event_contract_name

  """column name"""
  registering_event_log_index

  """column name"""
  registering_event_name

  """column name"""
  registering_event_src_address
}

"""
Streaming cursor of the table "dynamic_contract_registry"
"""
input dynamic_contract_registry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: dynamic_contract_registry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input dynamic_contract_registry_stream_cursor_value_input {
  chain_id: Int
  contract_address: String
  contract_type: contract_type
  id: String
  is_pre_registered: Boolean
  registering_event_block_number: Int
  registering_event_block_timestamp: Int
  registering_event_contract_name: String
  registering_event_log_index: Int
  registering_event_name: String
  registering_event_src_address: String
}

"""
columns and relationships of "end_of_block_range_scanned_data"
"""
type end_of_block_range_scanned_data {
  block_hash: String!
  block_number: Int!
  chain_id: Int!
}

"""
Boolean expression to filter rows from the table "end_of_block_range_scanned_data". All fields are combined with a logical 'AND'.
"""
input end_of_block_range_scanned_data_bool_exp {
  _and: [end_of_block_range_scanned_data_bool_exp!]
  _not: end_of_block_range_scanned_data_bool_exp
  _or: [end_of_block_range_scanned_data_bool_exp!]
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  chain_id: Int_comparison_exp
}

"""
Ordering options when selecting data from "end_of_block_range_scanned_data".
"""
input end_of_block_range_scanned_data_order_by {
  block_hash: order_by
  block_number: order_by
  chain_id: order_by
}

"""
select columns of table "end_of_block_range_scanned_data"
"""
enum end_of_block_range_scanned_data_select_column {
  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  chain_id
}

"""
Streaming cursor of the table "end_of_block_range_scanned_data"
"""
input end_of_block_range_scanned_data_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: end_of_block_range_scanned_data_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input end_of_block_range_scanned_data_stream_cursor_value_input {
  block_hash: String
  block_number: Int
  chain_id: Int
}

"""
columns and relationships of "event_sync_state"
"""
type event_sync_state {
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  is_pre_registering_dynamic_contracts: Boolean!
  log_index: Int!
}

"""
Boolean expression to filter rows from the table "event_sync_state". All fields are combined with a logical 'AND'.
"""
input event_sync_state_bool_exp {
  _and: [event_sync_state_bool_exp!]
  _not: event_sync_state_bool_exp
  _or: [event_sync_state_bool_exp!]
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  is_pre_registering_dynamic_contracts: Boolean_comparison_exp
  log_index: Int_comparison_exp
}

"""Ordering options when selecting data from "event_sync_state"."""
input event_sync_state_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  is_pre_registering_dynamic_contracts: order_by
  log_index: order_by
}

"""
select columns of table "event_sync_state"
"""
enum event_sync_state_select_column {
  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  is_pre_registering_dynamic_contracts

  """column name"""
  log_index
}

"""
Streaming cursor of the table "event_sync_state"
"""
input event_sync_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: event_sync_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input event_sync_state_stream_cursor_value_input {
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  is_pre_registering_dynamic_contracts: Boolean
  log_index: Int
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

scalar paymentordertype

"""
Boolean expression to compare columns of type "paymentordertype". All fields are combined with logical 'AND'.
"""
input paymentordertype_comparison_exp {
  _eq: paymentordertype
  _gt: paymentordertype
  _gte: paymentordertype
  _in: [paymentordertype!]
  _is_null: Boolean
  _lt: paymentordertype
  _lte: paymentordertype
  _neq: paymentordertype
  _nin: [paymentordertype!]
}

"""
columns and relationships of "persisted_state"
"""
type persisted_state {
  abi_files_hash: String!
  config_hash: String!
  envio_version: String!
  handler_files_hash: String!
  id: Int!
  schema_hash: String!
}

"""
Boolean expression to filter rows from the table "persisted_state". All fields are combined with a logical 'AND'.
"""
input persisted_state_bool_exp {
  _and: [persisted_state_bool_exp!]
  _not: persisted_state_bool_exp
  _or: [persisted_state_bool_exp!]
  abi_files_hash: String_comparison_exp
  config_hash: String_comparison_exp
  envio_version: String_comparison_exp
  handler_files_hash: String_comparison_exp
  id: Int_comparison_exp
  schema_hash: String_comparison_exp
}

"""Ordering options when selecting data from "persisted_state"."""
input persisted_state_order_by {
  abi_files_hash: order_by
  config_hash: order_by
  envio_version: order_by
  handler_files_hash: order_by
  id: order_by
  schema_hash: order_by
}

"""
select columns of table "persisted_state"
"""
enum persisted_state_select_column {
  """column name"""
  abi_files_hash

  """column name"""
  config_hash

  """column name"""
  envio_version

  """column name"""
  handler_files_hash

  """column name"""
  id

  """column name"""
  schema_hash
}

"""
Streaming cursor of the table "persisted_state"
"""
input persisted_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: persisted_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input persisted_state_stream_cursor_value_input {
  abi_files_hash: String
  config_hash: String
  envio_version: String
  handler_files_hash: String
  id: Int
  schema_hash: String
}

type query_root {
  """
  fetch data from the table: "AutRoles"
  """
  AutRoles(
    """distinct select on columns"""
    distinct_on: [AutRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [AutRoles_order_by!]

    """filter the rows returned"""
    where: AutRoles_bool_exp
  ): [AutRoles!]!

  """fetch data from the table: "AutRoles" using primary key columns"""
  AutRoles_by_pk(id: String!): AutRoles

  """
  fetch data from the table: "BondingCurve"
  """
  BondingCurve(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """
  fetch aggregated fields from the table: "BondingCurve"
  """
  BondingCurve_aggregate(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): BondingCurve_aggregate!

  """fetch data from the table: "BondingCurve" using primary key columns"""
  BondingCurve_by_pk(id: String!): BondingCurve

  """
  fetch data from the table: "Bounty"
  """
  Bounty(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!

  """
  fetch data from the table: "BountyClaim"
  """
  BountyClaim(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!

  """
  fetch aggregated fields from the table: "BountyClaim"
  """
  BountyClaim_aggregate(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): BountyClaim_aggregate!

  """fetch data from the table: "BountyClaim" using primary key columns"""
  BountyClaim_by_pk(id: String!): BountyClaim

  """
  fetch data from the table: "BountyContributor"
  """
  BountyContributor(
    """distinct select on columns"""
    distinct_on: [BountyContributor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyContributor_order_by!]

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!

  """
  fetch data from the table: "BountyContributor" using primary key columns
  """
  BountyContributor_by_pk(id: String!): BountyContributor

  """
  fetch data from the table: "BountyModule"
  """
  BountyModule(
    """distinct select on columns"""
    distinct_on: [BountyModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyModule_order_by!]

    """filter the rows returned"""
    where: BountyModule_bool_exp
  ): [BountyModule!]!

  """fetch data from the table: "BountyModule" using primary key columns"""
  BountyModule_by_pk(id: String!): BountyModule

  """
  fetch aggregated fields from the table: "Bounty"
  """
  Bounty_aggregate(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): Bounty_aggregate!

  """fetch data from the table: "Bounty" using primary key columns"""
  Bounty_by_pk(id: String!): Bounty

  """
  fetch data from the table: "CurveDayData"
  """
  CurveDayData(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """
  fetch aggregated fields from the table: "CurveDayData"
  """
  CurveDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): CurveDayData_aggregate!

  """fetch data from the table: "CurveDayData" using primary key columns"""
  CurveDayData_by_pk(id: String!): CurveDayData

  """
  fetch data from the table: "CurveHourData"
  """
  CurveHourData(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """
  fetch aggregated fields from the table: "CurveHourData"
  """
  CurveHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): CurveHourData_aggregate!

  """fetch data from the table: "CurveHourData" using primary key columns"""
  CurveHourData_by_pk(id: String!): CurveHourData

  """
  fetch data from the table: "Deposit"
  """
  Deposit(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!

  """
  fetch data from the table: "DepositVault"
  """
  DepositVault(
    """distinct select on columns"""
    distinct_on: [DepositVault_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DepositVault_order_by!]

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): [DepositVault!]!

  """
  fetch aggregated fields from the table: "DepositVault"
  """
  DepositVault_aggregate(
    """distinct select on columns"""
    distinct_on: [DepositVault_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DepositVault_order_by!]

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): DepositVault_aggregate!

  """fetch data from the table: "DepositVault" using primary key columns"""
  DepositVault_by_pk(id: String!): DepositVault

  """
  fetch aggregated fields from the table: "Deposit"
  """
  Deposit_aggregate(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): Deposit_aggregate!

  """fetch data from the table: "Deposit" using primary key columns"""
  Deposit_by_pk(id: String!): Deposit

  """
  fetch data from the table: "ExternalPrice"
  """
  ExternalPrice(
    """distinct select on columns"""
    distinct_on: [ExternalPrice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ExternalPrice_order_by!]

    """filter the rows returned"""
    where: ExternalPrice_bool_exp
  ): [ExternalPrice!]!

  """
  fetch data from the table: "ExternalPriceSetter"
  """
  ExternalPriceSetter(
    """distinct select on columns"""
    distinct_on: [ExternalPriceSetter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ExternalPriceSetter_order_by!]

    """filter the rows returned"""
    where: ExternalPriceSetter_bool_exp
  ): [ExternalPriceSetter!]!

  """
  fetch data from the table: "ExternalPriceSetter" using primary key columns
  """
  ExternalPriceSetter_by_pk(id: String!): ExternalPriceSetter

  """fetch data from the table: "ExternalPrice" using primary key columns"""
  ExternalPrice_by_pk(id: String!): ExternalPrice

  """
  fetch data from the table: "Graduation"
  """
  Graduation(
    """distinct select on columns"""
    distinct_on: [Graduation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Graduation_order_by!]

    """filter the rows returned"""
    where: Graduation_bool_exp
  ): [Graduation!]!

  """fetch data from the table: "Graduation" using primary key columns"""
  Graduation_by_pk(id: String!): Graduation

  """
  fetch data from the table: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """
  fetch aggregated fields from the table: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): IssuanceTokenDayData_aggregate!

  """
  fetch data from the table: "IssuanceTokenDayData" using primary key columns
  """
  IssuanceTokenDayData_by_pk(id: String!): IssuanceTokenDayData

  """
  fetch data from the table: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """
  fetch aggregated fields from the table: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): IssuanceTokenHourData_aggregate!

  """
  fetch data from the table: "IssuanceTokenHourData" using primary key columns
  """
  IssuanceTokenHourData_by_pk(id: String!): IssuanceTokenHourData

  """
  fetch data from the table: "LinearVesting"
  """
  LinearVesting(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """fetch data from the table: "LinearVesting" using primary key columns"""
  LinearVesting_by_pk(id: String!): LinearVesting

  """
  fetch data from the table: "MigratingPIM"
  """
  MigratingPIM(
    """distinct select on columns"""
    distinct_on: [MigratingPIM_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MigratingPIM_order_by!]

    """filter the rows returned"""
    where: MigratingPIM_bool_exp
  ): [MigratingPIM!]!

  """fetch data from the table: "MigratingPIM" using primary key columns"""
  MigratingPIM_by_pk(id: String!): MigratingPIM

  """
  fetch data from the table: "MigrationConfig"
  """
  MigrationConfig(
    """distinct select on columns"""
    distinct_on: [MigrationConfig_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MigrationConfig_order_by!]

    """filter the rows returned"""
    where: MigrationConfig_bool_exp
  ): [MigrationConfig!]!

  """fetch data from the table: "MigrationConfig" using primary key columns"""
  MigrationConfig_by_pk(id: String!): MigrationConfig

  """
  fetch data from the table: "OraclePriceFM"
  """
  OraclePriceFM(
    """distinct select on columns"""
    distinct_on: [OraclePriceFM_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [OraclePriceFM_order_by!]

    """filter the rows returned"""
    where: OraclePriceFM_bool_exp
  ): [OraclePriceFM!]!

  """
  fetch aggregated fields from the table: "OraclePriceFM"
  """
  OraclePriceFM_aggregate(
    """distinct select on columns"""
    distinct_on: [OraclePriceFM_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [OraclePriceFM_order_by!]

    """filter the rows returned"""
    where: OraclePriceFM_bool_exp
  ): OraclePriceFM_aggregate!

  """fetch data from the table: "OraclePriceFM" using primary key columns"""
  OraclePriceFM_by_pk(id: String!): OraclePriceFM

  """
  fetch data from the table: "OraclePriceOrder"
  """
  OraclePriceOrder(
    """distinct select on columns"""
    distinct_on: [OraclePriceOrder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [OraclePriceOrder_order_by!]

    """filter the rows returned"""
    where: OraclePriceOrder_bool_exp
  ): [OraclePriceOrder!]!

  """
  fetch data from the table: "OraclePriceOrder" using primary key columns
  """
  OraclePriceOrder_by_pk(id: String!): OraclePriceOrder

  """
  fetch data from the table: "ProjectFee"
  """
  ProjectFee(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """
  fetch aggregated fields from the table: "ProjectFee"
  """
  ProjectFee_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): ProjectFee_aggregate!

  """fetch data from the table: "ProjectFee" using primary key columns"""
  ProjectFee_by_pk(id: String!): ProjectFee

  """
  fetch data from the table: "ProtocolFee"
  """
  ProtocolFee(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """
  fetch aggregated fields from the table: "ProtocolFee"
  """
  ProtocolFee_aggregate(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): ProtocolFee_aggregate!

  """fetch data from the table: "ProtocolFee" using primary key columns"""
  ProtocolFee_by_pk(id: String!): ProtocolFee

  """
  fetch data from the table: "Role"
  """
  Role(
    """distinct select on columns"""
    distinct_on: [Role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Role_order_by!]

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!

  """fetch data from the table: "Role" using primary key columns"""
  Role_by_pk(id: String!): Role

  """
  fetch data from the table: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor(
    """distinct select on columns"""
    distinct_on: [StreamingPaymentProcessor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StreamingPaymentProcessor_order_by!]

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "StreamingPaymentProcessor" using primary key columns
  """
  StreamingPaymentProcessor_by_pk(id: String!): StreamingPaymentProcessor

  """
  fetch data from the table: "Swap"
  """
  Swap(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """fetch data from the table: "Swap" using primary key columns"""
  Swap_by_pk(id: String!): Swap

  """
  fetch data from the table: "Token"
  """
  Token(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """
  fetch aggregated fields from the table: "Token"
  """
  Token_aggregate(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): Token_aggregate!

  """fetch data from the table: "Token" using primary key columns"""
  Token_by_pk(id: String!): Token

  """
  fetch data from the table: "Transfer"
  """
  Transfer(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """
  fetch aggregated fields from the table: "Transfer"
  """
  Transfer_aggregate(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): Transfer_aggregate!

  """fetch data from the table: "Transfer" using primary key columns"""
  Transfer_by_pk(id: String!): Transfer

  """
  fetch data from the table: "Workflow"
  """
  Workflow(
    """distinct select on columns"""
    distinct_on: [Workflow_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Workflow_order_by!]

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "WorkflowModule"
  """
  WorkflowModule(
    """distinct select on columns"""
    distinct_on: [WorkflowModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModule_order_by!]

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """
  fetch data from the table: "WorkflowModuleType"
  """
  WorkflowModuleType(
    """distinct select on columns"""
    distinct_on: [WorkflowModuleType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModuleType_order_by!]

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """
  fetch data from the table: "WorkflowModuleType" using primary key columns
  """
  WorkflowModuleType_by_pk(id: String!): WorkflowModuleType

  """fetch data from the table: "WorkflowModule" using primary key columns"""
  WorkflowModule_by_pk(id: String!): WorkflowModule

  """fetch data from the table: "Workflow" using primary key columns"""
  Workflow_by_pk(id: String!): Workflow

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(id: String!): dynamic_contract_registry

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(serial: Int!): raw_events
}

"""
columns and relationships of "raw_events"
"""
type raw_events {
  block_fields(
    """JSON select path"""
    path: String
  ): jsonb!
  block_hash: String!
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  contract_name: String!
  db_write_timestamp: timestamp
  event_id: numeric!
  event_name: String!
  log_index: Int!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
  serial: Int!
  src_address: String!
  transaction_fields(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
Boolean expression to filter rows from the table "raw_events". All fields are combined with a logical 'AND'.
"""
input raw_events_bool_exp {
  _and: [raw_events_bool_exp!]
  _not: raw_events_bool_exp
  _or: [raw_events_bool_exp!]
  block_fields: jsonb_comparison_exp
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  contract_name: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  event_id: numeric_comparison_exp
  event_name: String_comparison_exp
  log_index: Int_comparison_exp
  params: jsonb_comparison_exp
  serial: Int_comparison_exp
  src_address: String_comparison_exp
  transaction_fields: jsonb_comparison_exp
}

"""Ordering options when selecting data from "raw_events"."""
input raw_events_order_by {
  block_fields: order_by
  block_hash: order_by
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  contract_name: order_by
  db_write_timestamp: order_by
  event_id: order_by
  event_name: order_by
  log_index: order_by
  params: order_by
  serial: order_by
  src_address: order_by
  transaction_fields: order_by
}

"""
select columns of table "raw_events"
"""
enum raw_events_select_column {
  """column name"""
  block_fields

  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  contract_name

  """column name"""
  db_write_timestamp

  """column name"""
  event_id

  """column name"""
  event_name

  """column name"""
  log_index

  """column name"""
  params

  """column name"""
  serial

  """column name"""
  src_address

  """column name"""
  transaction_fields
}

"""
Streaming cursor of the table "raw_events"
"""
input raw_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: raw_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input raw_events_stream_cursor_value_input {
  block_fields: jsonb
  block_hash: String
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  contract_name: String
  db_write_timestamp: timestamp
  event_id: numeric
  event_name: String
  log_index: Int
  params: jsonb
  serial: Int
  src_address: String
  transaction_fields: jsonb
}

scalar redemptionstate

"""
Boolean expression to compare columns of type "redemptionstate". All fields are combined with logical 'AND'.
"""
input redemptionstate_comparison_exp {
  _eq: redemptionstate
  _gt: redemptionstate
  _gte: redemptionstate
  _in: [redemptionstate!]
  _is_null: Boolean
  _lt: redemptionstate
  _lte: redemptionstate
  _neq: redemptionstate
  _nin: [redemptionstate!]
}

scalar rolestatus

"""
Boolean expression to compare columns of type "rolestatus". All fields are combined with logical 'AND'.
"""
input rolestatus_comparison_exp {
  _eq: rolestatus
  _gt: rolestatus
  _gte: rolestatus
  _in: [rolestatus!]
  _is_null: Boolean
  _lt: rolestatus
  _lte: rolestatus
  _neq: rolestatus
  _nin: [rolestatus!]
}

scalar sourcetokentype

"""
Boolean expression to compare columns of type "sourcetokentype". All fields are combined with logical 'AND'.
"""
input sourcetokentype_comparison_exp {
  _eq: sourcetokentype
  _gt: sourcetokentype
  _gte: sourcetokentype
  _in: [sourcetokentype!]
  _is_null: Boolean
  _lt: sourcetokentype
  _lte: sourcetokentype
  _neq: sourcetokentype
  _nin: [sourcetokentype!]
}

type subscription_root {
  """
  fetch data from the table: "AutRoles"
  """
  AutRoles(
    """distinct select on columns"""
    distinct_on: [AutRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [AutRoles_order_by!]

    """filter the rows returned"""
    where: AutRoles_bool_exp
  ): [AutRoles!]!

  """fetch data from the table: "AutRoles" using primary key columns"""
  AutRoles_by_pk(id: String!): AutRoles

  """
  fetch data from the table in a streaming manner: "AutRoles"
  """
  AutRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AutRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: AutRoles_bool_exp
  ): [AutRoles!]!

  """
  fetch data from the table: "BondingCurve"
  """
  BondingCurve(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """
  fetch aggregated fields from the table: "BondingCurve"
  """
  BondingCurve_aggregate(
    """distinct select on columns"""
    distinct_on: [BondingCurve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BondingCurve_order_by!]

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): BondingCurve_aggregate!

  """fetch data from the table: "BondingCurve" using primary key columns"""
  BondingCurve_by_pk(id: String!): BondingCurve

  """
  fetch data from the table in a streaming manner: "BondingCurve"
  """
  BondingCurve_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BondingCurve_stream_cursor_input]!

    """filter the rows returned"""
    where: BondingCurve_bool_exp
  ): [BondingCurve!]!

  """
  fetch data from the table: "Bounty"
  """
  Bounty(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!

  """
  fetch data from the table: "BountyClaim"
  """
  BountyClaim(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!

  """
  fetch aggregated fields from the table: "BountyClaim"
  """
  BountyClaim_aggregate(
    """distinct select on columns"""
    distinct_on: [BountyClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyClaim_order_by!]

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): BountyClaim_aggregate!

  """fetch data from the table: "BountyClaim" using primary key columns"""
  BountyClaim_by_pk(id: String!): BountyClaim

  """
  fetch data from the table in a streaming manner: "BountyClaim"
  """
  BountyClaim_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BountyClaim_stream_cursor_input]!

    """filter the rows returned"""
    where: BountyClaim_bool_exp
  ): [BountyClaim!]!

  """
  fetch data from the table: "BountyContributor"
  """
  BountyContributor(
    """distinct select on columns"""
    distinct_on: [BountyContributor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyContributor_order_by!]

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!

  """
  fetch data from the table: "BountyContributor" using primary key columns
  """
  BountyContributor_by_pk(id: String!): BountyContributor

  """
  fetch data from the table in a streaming manner: "BountyContributor"
  """
  BountyContributor_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BountyContributor_stream_cursor_input]!

    """filter the rows returned"""
    where: BountyContributor_bool_exp
  ): [BountyContributor!]!

  """
  fetch data from the table: "BountyModule"
  """
  BountyModule(
    """distinct select on columns"""
    distinct_on: [BountyModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [BountyModule_order_by!]

    """filter the rows returned"""
    where: BountyModule_bool_exp
  ): [BountyModule!]!

  """fetch data from the table: "BountyModule" using primary key columns"""
  BountyModule_by_pk(id: String!): BountyModule

  """
  fetch data from the table in a streaming manner: "BountyModule"
  """
  BountyModule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BountyModule_stream_cursor_input]!

    """filter the rows returned"""
    where: BountyModule_bool_exp
  ): [BountyModule!]!

  """
  fetch aggregated fields from the table: "Bounty"
  """
  Bounty_aggregate(
    """distinct select on columns"""
    distinct_on: [Bounty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Bounty_order_by!]

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): Bounty_aggregate!

  """fetch data from the table: "Bounty" using primary key columns"""
  Bounty_by_pk(id: String!): Bounty

  """
  fetch data from the table in a streaming manner: "Bounty"
  """
  Bounty_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Bounty_stream_cursor_input]!

    """filter the rows returned"""
    where: Bounty_bool_exp
  ): [Bounty!]!

  """
  fetch data from the table: "CurveDayData"
  """
  CurveDayData(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """
  fetch aggregated fields from the table: "CurveDayData"
  """
  CurveDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveDayData_order_by!]

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): CurveDayData_aggregate!

  """fetch data from the table: "CurveDayData" using primary key columns"""
  CurveDayData_by_pk(id: String!): CurveDayData

  """
  fetch data from the table in a streaming manner: "CurveDayData"
  """
  CurveDayData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CurveDayData_stream_cursor_input]!

    """filter the rows returned"""
    where: CurveDayData_bool_exp
  ): [CurveDayData!]!

  """
  fetch data from the table: "CurveHourData"
  """
  CurveHourData(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """
  fetch aggregated fields from the table: "CurveHourData"
  """
  CurveHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [CurveHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CurveHourData_order_by!]

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): CurveHourData_aggregate!

  """fetch data from the table: "CurveHourData" using primary key columns"""
  CurveHourData_by_pk(id: String!): CurveHourData

  """
  fetch data from the table in a streaming manner: "CurveHourData"
  """
  CurveHourData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CurveHourData_stream_cursor_input]!

    """filter the rows returned"""
    where: CurveHourData_bool_exp
  ): [CurveHourData!]!

  """
  fetch data from the table: "Deposit"
  """
  Deposit(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!

  """
  fetch data from the table: "DepositVault"
  """
  DepositVault(
    """distinct select on columns"""
    distinct_on: [DepositVault_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DepositVault_order_by!]

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): [DepositVault!]!

  """
  fetch aggregated fields from the table: "DepositVault"
  """
  DepositVault_aggregate(
    """distinct select on columns"""
    distinct_on: [DepositVault_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [DepositVault_order_by!]

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): DepositVault_aggregate!

  """fetch data from the table: "DepositVault" using primary key columns"""
  DepositVault_by_pk(id: String!): DepositVault

  """
  fetch data from the table in a streaming manner: "DepositVault"
  """
  DepositVault_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DepositVault_stream_cursor_input]!

    """filter the rows returned"""
    where: DepositVault_bool_exp
  ): [DepositVault!]!

  """
  fetch aggregated fields from the table: "Deposit"
  """
  Deposit_aggregate(
    """distinct select on columns"""
    distinct_on: [Deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Deposit_order_by!]

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): Deposit_aggregate!

  """fetch data from the table: "Deposit" using primary key columns"""
  Deposit_by_pk(id: String!): Deposit

  """
  fetch data from the table in a streaming manner: "Deposit"
  """
  Deposit_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Deposit_stream_cursor_input]!

    """filter the rows returned"""
    where: Deposit_bool_exp
  ): [Deposit!]!

  """
  fetch data from the table: "ExternalPrice"
  """
  ExternalPrice(
    """distinct select on columns"""
    distinct_on: [ExternalPrice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ExternalPrice_order_by!]

    """filter the rows returned"""
    where: ExternalPrice_bool_exp
  ): [ExternalPrice!]!

  """
  fetch data from the table: "ExternalPriceSetter"
  """
  ExternalPriceSetter(
    """distinct select on columns"""
    distinct_on: [ExternalPriceSetter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ExternalPriceSetter_order_by!]

    """filter the rows returned"""
    where: ExternalPriceSetter_bool_exp
  ): [ExternalPriceSetter!]!

  """
  fetch data from the table: "ExternalPriceSetter" using primary key columns
  """
  ExternalPriceSetter_by_pk(id: String!): ExternalPriceSetter

  """
  fetch data from the table in a streaming manner: "ExternalPriceSetter"
  """
  ExternalPriceSetter_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ExternalPriceSetter_stream_cursor_input]!

    """filter the rows returned"""
    where: ExternalPriceSetter_bool_exp
  ): [ExternalPriceSetter!]!

  """fetch data from the table: "ExternalPrice" using primary key columns"""
  ExternalPrice_by_pk(id: String!): ExternalPrice

  """
  fetch data from the table in a streaming manner: "ExternalPrice"
  """
  ExternalPrice_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ExternalPrice_stream_cursor_input]!

    """filter the rows returned"""
    where: ExternalPrice_bool_exp
  ): [ExternalPrice!]!

  """
  fetch data from the table: "Graduation"
  """
  Graduation(
    """distinct select on columns"""
    distinct_on: [Graduation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Graduation_order_by!]

    """filter the rows returned"""
    where: Graduation_bool_exp
  ): [Graduation!]!

  """fetch data from the table: "Graduation" using primary key columns"""
  Graduation_by_pk(id: String!): Graduation

  """
  fetch data from the table in a streaming manner: "Graduation"
  """
  Graduation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Graduation_stream_cursor_input]!

    """filter the rows returned"""
    where: Graduation_bool_exp
  ): [Graduation!]!

  """
  fetch data from the table: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """
  fetch aggregated fields from the table: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenDayData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenDayData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): IssuanceTokenDayData_aggregate!

  """
  fetch data from the table: "IssuanceTokenDayData" using primary key columns
  """
  IssuanceTokenDayData_by_pk(id: String!): IssuanceTokenDayData

  """
  fetch data from the table in a streaming manner: "IssuanceTokenDayData"
  """
  IssuanceTokenDayData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [IssuanceTokenDayData_stream_cursor_input]!

    """filter the rows returned"""
    where: IssuanceTokenDayData_bool_exp
  ): [IssuanceTokenDayData!]!

  """
  fetch data from the table: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """
  fetch aggregated fields from the table: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData_aggregate(
    """distinct select on columns"""
    distinct_on: [IssuanceTokenHourData_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [IssuanceTokenHourData_order_by!]

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): IssuanceTokenHourData_aggregate!

  """
  fetch data from the table: "IssuanceTokenHourData" using primary key columns
  """
  IssuanceTokenHourData_by_pk(id: String!): IssuanceTokenHourData

  """
  fetch data from the table in a streaming manner: "IssuanceTokenHourData"
  """
  IssuanceTokenHourData_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [IssuanceTokenHourData_stream_cursor_input]!

    """filter the rows returned"""
    where: IssuanceTokenHourData_bool_exp
  ): [IssuanceTokenHourData!]!

  """
  fetch data from the table: "LinearVesting"
  """
  LinearVesting(
    """distinct select on columns"""
    distinct_on: [LinearVesting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LinearVesting_order_by!]

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """fetch data from the table: "LinearVesting" using primary key columns"""
  LinearVesting_by_pk(id: String!): LinearVesting

  """
  fetch data from the table in a streaming manner: "LinearVesting"
  """
  LinearVesting_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LinearVesting_stream_cursor_input]!

    """filter the rows returned"""
    where: LinearVesting_bool_exp
  ): [LinearVesting!]!

  """
  fetch data from the table: "MigratingPIM"
  """
  MigratingPIM(
    """distinct select on columns"""
    distinct_on: [MigratingPIM_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MigratingPIM_order_by!]

    """filter the rows returned"""
    where: MigratingPIM_bool_exp
  ): [MigratingPIM!]!

  """fetch data from the table: "MigratingPIM" using primary key columns"""
  MigratingPIM_by_pk(id: String!): MigratingPIM

  """
  fetch data from the table in a streaming manner: "MigratingPIM"
  """
  MigratingPIM_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MigratingPIM_stream_cursor_input]!

    """filter the rows returned"""
    where: MigratingPIM_bool_exp
  ): [MigratingPIM!]!

  """
  fetch data from the table: "MigrationConfig"
  """
  MigrationConfig(
    """distinct select on columns"""
    distinct_on: [MigrationConfig_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MigrationConfig_order_by!]

    """filter the rows returned"""
    where: MigrationConfig_bool_exp
  ): [MigrationConfig!]!

  """fetch data from the table: "MigrationConfig" using primary key columns"""
  MigrationConfig_by_pk(id: String!): MigrationConfig

  """
  fetch data from the table in a streaming manner: "MigrationConfig"
  """
  MigrationConfig_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MigrationConfig_stream_cursor_input]!

    """filter the rows returned"""
    where: MigrationConfig_bool_exp
  ): [MigrationConfig!]!

  """
  fetch data from the table: "OraclePriceFM"
  """
  OraclePriceFM(
    """distinct select on columns"""
    distinct_on: [OraclePriceFM_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [OraclePriceFM_order_by!]

    """filter the rows returned"""
    where: OraclePriceFM_bool_exp
  ): [OraclePriceFM!]!

  """
  fetch aggregated fields from the table: "OraclePriceFM"
  """
  OraclePriceFM_aggregate(
    """distinct select on columns"""
    distinct_on: [OraclePriceFM_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [OraclePriceFM_order_by!]

    """filter the rows returned"""
    where: OraclePriceFM_bool_exp
  ): OraclePriceFM_aggregate!

  """fetch data from the table: "OraclePriceFM" using primary key columns"""
  OraclePriceFM_by_pk(id: String!): OraclePriceFM

  """
  fetch data from the table in a streaming manner: "OraclePriceFM"
  """
  OraclePriceFM_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [OraclePriceFM_stream_cursor_input]!

    """filter the rows returned"""
    where: OraclePriceFM_bool_exp
  ): [OraclePriceFM!]!

  """
  fetch data from the table: "OraclePriceOrder"
  """
  OraclePriceOrder(
    """distinct select on columns"""
    distinct_on: [OraclePriceOrder_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [OraclePriceOrder_order_by!]

    """filter the rows returned"""
    where: OraclePriceOrder_bool_exp
  ): [OraclePriceOrder!]!

  """
  fetch data from the table: "OraclePriceOrder" using primary key columns
  """
  OraclePriceOrder_by_pk(id: String!): OraclePriceOrder

  """
  fetch data from the table in a streaming manner: "OraclePriceOrder"
  """
  OraclePriceOrder_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [OraclePriceOrder_stream_cursor_input]!

    """filter the rows returned"""
    where: OraclePriceOrder_bool_exp
  ): [OraclePriceOrder!]!

  """
  fetch data from the table: "ProjectFee"
  """
  ProjectFee(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """
  fetch aggregated fields from the table: "ProjectFee"
  """
  ProjectFee_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectFee_order_by!]

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): ProjectFee_aggregate!

  """fetch data from the table: "ProjectFee" using primary key columns"""
  ProjectFee_by_pk(id: String!): ProjectFee

  """
  fetch data from the table in a streaming manner: "ProjectFee"
  """
  ProjectFee_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProjectFee_stream_cursor_input]!

    """filter the rows returned"""
    where: ProjectFee_bool_exp
  ): [ProjectFee!]!

  """
  fetch data from the table: "ProtocolFee"
  """
  ProtocolFee(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """
  fetch aggregated fields from the table: "ProtocolFee"
  """
  ProtocolFee_aggregate(
    """distinct select on columns"""
    distinct_on: [ProtocolFee_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProtocolFee_order_by!]

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): ProtocolFee_aggregate!

  """fetch data from the table: "ProtocolFee" using primary key columns"""
  ProtocolFee_by_pk(id: String!): ProtocolFee

  """
  fetch data from the table in a streaming manner: "ProtocolFee"
  """
  ProtocolFee_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProtocolFee_stream_cursor_input]!

    """filter the rows returned"""
    where: ProtocolFee_bool_exp
  ): [ProtocolFee!]!

  """
  fetch data from the table: "Role"
  """
  Role(
    """distinct select on columns"""
    distinct_on: [Role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Role_order_by!]

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!

  """fetch data from the table: "Role" using primary key columns"""
  Role_by_pk(id: String!): Role

  """
  fetch data from the table in a streaming manner: "Role"
  """
  Role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Role_stream_cursor_input]!

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!

  """
  fetch data from the table: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor(
    """distinct select on columns"""
    distinct_on: [StreamingPaymentProcessor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StreamingPaymentProcessor_order_by!]

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "StreamingPaymentProcessor" using primary key columns
  """
  StreamingPaymentProcessor_by_pk(id: String!): StreamingPaymentProcessor

  """
  fetch data from the table in a streaming manner: "StreamingPaymentProcessor"
  """
  StreamingPaymentProcessor_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [StreamingPaymentProcessor_stream_cursor_input]!

    """filter the rows returned"""
    where: StreamingPaymentProcessor_bool_exp
  ): [StreamingPaymentProcessor!]!

  """
  fetch data from the table: "Swap"
  """
  Swap(
    """distinct select on columns"""
    distinct_on: [Swap_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Swap_order_by!]

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """fetch data from the table: "Swap" using primary key columns"""
  Swap_by_pk(id: String!): Swap

  """
  fetch data from the table in a streaming manner: "Swap"
  """
  Swap_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Swap_stream_cursor_input]!

    """filter the rows returned"""
    where: Swap_bool_exp
  ): [Swap!]!

  """
  fetch data from the table: "Token"
  """
  Token(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """
  fetch aggregated fields from the table: "Token"
  """
  Token_aggregate(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): Token_aggregate!

  """fetch data from the table: "Token" using primary key columns"""
  Token_by_pk(id: String!): Token

  """
  fetch data from the table in a streaming manner: "Token"
  """
  Token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Token_stream_cursor_input]!

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """
  fetch data from the table: "Transfer"
  """
  Transfer(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """
  fetch aggregated fields from the table: "Transfer"
  """
  Transfer_aggregate(
    """distinct select on columns"""
    distinct_on: [Transfer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Transfer_order_by!]

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): Transfer_aggregate!

  """fetch data from the table: "Transfer" using primary key columns"""
  Transfer_by_pk(id: String!): Transfer

  """
  fetch data from the table in a streaming manner: "Transfer"
  """
  Transfer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Transfer_stream_cursor_input]!

    """filter the rows returned"""
    where: Transfer_bool_exp
  ): [Transfer!]!

  """
  fetch data from the table: "Workflow"
  """
  Workflow(
    """distinct select on columns"""
    distinct_on: [Workflow_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Workflow_order_by!]

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "WorkflowModule"
  """
  WorkflowModule(
    """distinct select on columns"""
    distinct_on: [WorkflowModule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModule_order_by!]

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """
  fetch data from the table: "WorkflowModuleType"
  """
  WorkflowModuleType(
    """distinct select on columns"""
    distinct_on: [WorkflowModuleType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WorkflowModuleType_order_by!]

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """
  fetch data from the table: "WorkflowModuleType" using primary key columns
  """
  WorkflowModuleType_by_pk(id: String!): WorkflowModuleType

  """
  fetch data from the table in a streaming manner: "WorkflowModuleType"
  """
  WorkflowModuleType_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [WorkflowModuleType_stream_cursor_input]!

    """filter the rows returned"""
    where: WorkflowModuleType_bool_exp
  ): [WorkflowModuleType!]!

  """fetch data from the table: "WorkflowModule" using primary key columns"""
  WorkflowModule_by_pk(id: String!): WorkflowModule

  """
  fetch data from the table in a streaming manner: "WorkflowModule"
  """
  WorkflowModule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [WorkflowModule_stream_cursor_input]!

    """filter the rows returned"""
    where: WorkflowModule_bool_exp
  ): [WorkflowModule!]!

  """fetch data from the table: "Workflow" using primary key columns"""
  Workflow_by_pk(id: String!): Workflow

  """
  fetch data from the table in a streaming manner: "Workflow"
  """
  Workflow_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Workflow_stream_cursor_input]!

    """filter the rows returned"""
    where: Workflow_bool_exp
  ): [Workflow!]!

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table in a streaming manner: "chain_metadata"
  """
  chain_metadata_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chain_metadata_stream_cursor_input]!

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(id: String!): dynamic_contract_registry

  """
  fetch data from the table in a streaming manner: "dynamic_contract_registry"
  """
  dynamic_contract_registry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [dynamic_contract_registry_stream_cursor_input]!

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table in a streaming manner: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [end_of_block_range_scanned_data_stream_cursor_input]!

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """
  fetch data from the table in a streaming manner: "event_sync_state"
  """
  event_sync_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [event_sync_state_stream_cursor_input]!

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table in a streaming manner: "persisted_state"
  """
  persisted_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [persisted_state_stream_cursor_input]!

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(serial: Int!): raw_events

  """
  fetch data from the table in a streaming manner: "raw_events"
  """
  raw_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [raw_events_stream_cursor_input]!

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!
}

scalar swaptype

"""
Boolean expression to compare columns of type "swaptype". All fields are combined with logical 'AND'.
"""
input swaptype_comparison_exp {
  _eq: swaptype
  _gt: swaptype
  _gte: swaptype
  _in: [swaptype!]
  _is_null: Boolean
  _lt: swaptype
  _lte: swaptype
  _neq: swaptype
  _nin: [swaptype!]
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar vestingstatus

"""
Boolean expression to compare columns of type "vestingstatus". All fields are combined with logical 'AND'.
"""
input vestingstatus_comparison_exp {
  _eq: vestingstatus
  _gt: vestingstatus
  _gte: vestingstatus
  _in: [vestingstatus!]
  _is_null: Boolean
  _lt: vestingstatus
  _lte: vestingstatus
  _neq: vestingstatus
  _nin: [vestingstatus!]
}